<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vue.js D3 Graph Chat UI - LLM Controlled</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css"
    crossorigin="anonymous"
  />
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"
    crossorigin="anonymous"
  ></script>
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"
    crossorigin="anonymous"
  ></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
    .animate-blink { animation: blink 1s step-end infinite; }
    .rendered-content { display: inline-block; width: 100%; }
    .typing-cursor { display: inline-block; width: 2px; height: 1.2em; background-color: currentcolor; vertical-align: text-bottom; margin-left: 1px; }
    .katex-display > .katex { text-align: initial; overflow-x: auto; overflow-y: hidden; max-width: 100%; }
    #chat-container::-webkit-scrollbar { width: 6px; }
    #chat-container::-webkit-scrollbar-track { background: transparent; }
    #chat-container::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.1); border-radius: 10px; }
    .dark #chat-container::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.1); }
    #chat-container::-webkit-scrollbar-thumb:hover { background-color: rgba(0,0,0,0.2); }
    .dark #chat-container::-webkit-scrollbar-thumb:hover { background-color: rgba(255,255,255,0.2); }
    .shadow-top-lg { box-shadow: 0 -12px 20px -5px rgb(0 0 0 / 0.05), 0 -5px 8px -6px rgb(0 0 0 / 0.05); }
    .dark .shadow-top-lg { box-shadow: 0 -12px 20px -5px rgb(0 0 0 / 0.1), 0 -5px 8px -6px rgb(0 0 0 / 0.1); }
    .link { stroke: #9ca3af; stroke-width: 1.5px; }
    .dark .link { stroke: #6b7280; }
    .sticky-note { rx: 5; ry: 5; }
    .note-label { pointer-events: none; font-size: 12px; text-anchor: middle; dominant-baseline: central; fill: #1f2937; }
    .dark .note-label { fill: #f3f4f6; }
    .graph-host-container {
        height: 350px;
        width: 100%;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        margin-top: 1rem;
        margin-bottom: 1rem;
        transition: opacity 0.5s ease-in-out, max-height 0.5s ease-in-out;
        overflow: hidden;
    }
  </style>
</head>
<body class="bg-slate-100 dark:bg-slate-950 text-slate-800 dark:text-slate-200 antialiased">

  <div id="app" class="flex flex-col h-screen w-full">
    <div id="chat-ui-area" class="flex-1 flex flex-col overflow-hidden bg-slate-100 dark:bg-slate-950">
      <div ref="chatContainerRef" id="chat-container" class="flex-1 p-4 sm:p-6 overflow-y-auto flex flex-col space-y-5">
        <message-item
          v-for="msg in messages"
          :key="msg.id"
          :message="msg"
          @edit="startEdit"
          @copy="performCopy"
        ></message-item>
      </div>
      <form @submit.prevent="handleSendMessage" class="p-3 sm:p-4 bg-gray-700/50 dark:bg-black/60 backdrop-blur-xl border-t border-gray-500/20 dark:border-slate-700/30 shadow-top-lg">
        <div class="relative flex items-center space-x-2">
          <textarea
            id="message-input" rows="1" v-model="newMessageText"
            @keydown.enter.exact.prevent="handleSendMessage" @input="autoGrowTextarea"
            class="flex-grow resize-none border border-gray-600/30 dark:border-slate-700/40 rounded-xl focus:ring-2 focus:ring-sky-500/80 focus:border-sky-500/80 sm:text-sm bg-gray-800/20 dark:bg-black/40 backdrop-blur-sm text-slate-800 dark:text-slate-100 py-2.5 px-3.5 placeholder-gray-500 dark:placeholder-slate-500 overflow-y-hidden max-h-32"
            style="line-height: 1.5rem;" placeholder="Type your message or graph command..." :disabled="isLoading"
          ></textarea>
          <button type="button" @click="clearInput" :disabled="isLoading" title="Clear input" class="flex-shrink-0 w-10 h-10 flex items-center justify-center rounded-full text-gray-400 dark:text-slate-500 hover:bg-gray-600/30 dark:hover:bg-slate-700/50 focus:outline-none focus:ring-1 focus:ring-gray-500/50 dark:focus:ring-slate-600 disabled:opacity-50 transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9.75L14.25 12m0 0L12 14.25m2.25-2.25L14.25 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          </button>
          <button type="submit" :disabled="isLoading || !newMessageText.trim() && !editingMessage" class="flex-shrink-0 w-10 h-10 flex items-center justify-center text-white bg-sky-500 rounded-full hover:bg-sky-600 focus:ring-2 focus:outline-none focus:ring-sky-400 dark:focus:ring-sky-600 disabled:bg-sky-500/60 disabled:cursor-not-allowed transition-colors" title="Send message">
            <span v-if="isLoading"><svg aria-hidden="true" class="w-5 h-5 text-white animate-spin fill-sky-200 dark:fill-sky-700" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0492C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"/></svg></span>
            <span v-else><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" /></svg></span>
          </button>
        </div>
      </form>
    </div>
  </div>

  <script type="module">
    import { createApp, ref, nextTick, watch, onMounted, onUpdated, onBeforeUnmount } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

    const API_KEY = "AIzaSyCvtMPDKK4oT_-1RB0MBOYoDwPjme6akoY"; // !!! REPLACE WITH YOUR ACTUAL GEMINI API KEY !!!
    const MODEL_NAME = "gemini-2.5-flash-lite-preview-06-17";
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${API_KEY}`;

    const d3GraphManager = {
        svg: null, simulation: null, graph: { nodes: [], links: [] },
        noteWidth: 120, noteHeight: 70, activeContainerElement: null, resizeObserver: null,
        localStorageKey: 'd3GraphChatUIData',
        isDarkMode: () => document.documentElement.classList.contains('dark'),

        loadFromLocalStorage() {
            try {
                const storedData = localStorage.getItem(this.localStorageKey);
                if (storedData) {
                    const parsedData = JSON.parse(storedData);
                    // Basic validation
                    if (parsedData && Array.isArray(parsedData.nodes) && Array.isArray(parsedData.links)) {
                        this.graph = parsedData;
                        console.log("Graph data loaded from localStorage.");
                        return true;
                    } else {
                        console.warn("Invalid graph data structure in localStorage.");
                        this.graph = { nodes: [], links: [] }; // Reset to default
                    }
                }
            } catch (error) {
                console.error("Error loading graph data from localStorage:", error);
                this.graph = { nodes: [], links: [] }; // Reset to default on error
            }
            return false;
        },

        saveToLocalStorage() {
            try {
                localStorage.setItem(this.localStorageKey, JSON.stringify(this.graph));
                // console.log("Graph data saved to localStorage.");
            } catch (error) {
                console.error("Error saving graph data to localStorage:", error);
            }
        },

        init() {
            this.loadFromLocalStorage(); // Load first
            // If nothing loaded, graph is already { nodes: [], links: [] } from loadFromLocalStorage or default
        },
        ensureInitialized(containerElement) {
            if (!containerElement) return;
            if (this.activeContainerElement === containerElement && this.svg) { /* ... resize check ... */ return; } // Simplified for brevity
            this.destroyVisualization();
            this.activeContainerElement = containerElement;
            const width = containerElement.clientWidth || 600, height = containerElement.clientHeight || 350;
            this.svg = d3.select(containerElement).append("svg")
                .attr("width", "100%").attr("height", "100%")
                .attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet");
            this.simulation = d3.forceSimulation(this.graph.nodes) // Use this.graph which might be loaded
                .force("link", d3.forceLink(this.graph.links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", this.ticked.bind(this));
            this.svg.append("g").attr("class", "links"); this.svg.append("g").attr("class", "notes"); this.svg.append("g").attr("class", "labels");
            let rt; const hr = () => { /* ... resize handler ... */ }; // Simplified
            const dbr = () => { clearTimeout(rt); rt = setTimeout(hr, 150); };
            this.resizeObserver = new ResizeObserver(dbr); this.resizeObserver.observe(containerElement);
            if (width > 0 && height > 0) hr();
            this.update(); // Update with potentially loaded data
        },
        destroyVisualization() { /* ... same as before ... */ },
        ticked() { /* ... same as before ... */ },
        update() {
            if (!this.svg || !this.simulation || !this.activeContainerElement) return;
            this.simulation.nodes(this.graph.nodes); this.simulation.force("link").links(this.graph.links);
            const df = this.isDarkMode()?"#334155":"#fefce8", ds = this.isDarkMode()?"#64748b":"#facc15";
            const link = this.svg.select("g.links").selectAll("line").data(this.graph.links, d=>`${d.source.id||d.source}-${d.target.id||d.target}`);
            link.exit().remove(); link.enter().append("line").attr("class", "link").style("stroke", this.isDarkMode()?"#6b7280":"#9ca3af");
            const notes = this.svg.select("g.notes").selectAll("rect").data(this.graph.nodes, d=>d.id);
            notes.exit().remove();
            notes.enter().append("rect").attr("class", "sticky-note").attr("width", this.noteWidth).attr("height", this.noteHeight)
                .call(d3.drag().on("start",this.dragStarted.bind(this)).on("drag",this.dragged.bind(this)).on("end",this.dragEnded.bind(this)))
                .merge(notes).style("fill",d=>d.isHighlighted?(this.isDarkMode()?"#60a5fa":"#bfdbfe"):df).style("stroke",d=>d.isHighlighted?(this.isDarkMode()?"#93c5fd":"#60a5fa"):ds).style("stroke-width",1.5);
            const labels = this.svg.select("g.labels").selectAll("text").data(this.graph.nodes, d=>d.id);
            labels.exit().remove();
            labels.enter().append("text").attr("class", "note-label").merge(labels)
                .text(d=>d.id.length>18?d.id.substring(0,15)+"...":d.id).style("fill", this.isDarkMode()?"#f3f4f6":"#1f2937");
            this.simulation.alpha(0.3).restart();
        },
        dragStarted(ev,d){if(!ev.active&&this.simulation)this.simulation.alphaTarget(0.3).restart();d.fx=d.x;d.fy=d.y;},
        dragged(ev,d){d.fx=ev.x;d.fy=ev.y;},
        dragEnded(ev,d){if(!ev.active&&this.simulation)this.simulation.alphaTarget(0);},
        addNode(id,body=""){if(!id||typeof id!=='string'||id.trim()==="")return{success:false,message:"ID empty."};id=id.trim();if(!this.graph.nodes.find(n=>n.id===id)){this.graph.nodes.push({id:id,body:body||"",isHighlighted:false});this.update();this.saveToLocalStorage();return{success:true,message:`Note "${id}" created.`};}return{success:false,message:`Note "${id}" exists.`};},
        addLink(srcId,tgtId){if(!srcId||!tgtId)return{success:false,message:"IDs required."};srcId=srcId.trim();tgtId=tgtId.trim();if(srcId===tgtId)return{success:false,message:"Self-link."};const sn=this.graph.nodes.find(n=>n.id===srcId),tn=this.graph.nodes.find(n=>n.id===tgtId);if(!sn)return{success:false,message:`Src "${srcId}" missing.`};if(!tn)return{success:false,message:`Tgt "${tgtId}" missing.`};const le=this.graph.links.find(l=>(l.source.id===srcId&&l.target.id===tgtId)||(l.source.id===tgtId&&l.target.id===srcId));if(!le){this.graph.links.push({source:srcId,target:tgtId});this.update();this.saveToLocalStorage();return{success:true,message:`Linked "${srcId}"-"${tgtId}".`};}return{success:false,message:`Link exists.`};},
        deleteNode(id){id=id.trim();const ne=this.graph.nodes.find(n=>n.id===id);if(!ne)return{success:false,message:`Note "${id}" missing.`};this.graph.nodes=this.graph.nodes.filter(n=>n.id!==id);this.graph.links=this.graph.links.filter(l=>(l.source.id||l.source)!==id&&(l.target.id||l.target)!==id);this.update();this.saveToLocalStorage();return{success:true,message:`Note "${id}" deleted.`};},
        highlightSearch(q){const nq=q?q.trim().toLowerCase():"";this.graph.nodes.forEach(n=>{n.isHighlighted=nq&&(n.id.toLowerCase().includes(nq)||(n.body&&n.body.toLowerCase().includes(nq)))});this.update();return{success:true,message:nq?`Highlight: "${q}".`:"Highlight cleared."};}, // No save for highlight
        clearGraphData(){this.graph.nodes=[];this.graph.links=[];this.update();this.saveToLocalStorage();return{success:true,message:"Graph data cleared."};}
    };
    // Ensure `destroyVisualization`, `ticked`, `drag*` and parts of `ensureInitialized` are fully defined as before...
    d3GraphManager.destroyVisualization = function() {
        if (this.resizeObserver && this.activeContainerElement) { this.resizeObserver.unobserve(this.activeContainerElement); this.resizeObserver.disconnect(); this.resizeObserver = null; }
        if (this.svg) { this.svg.remove(); this.svg = null; }
        if (this.simulation) { this.simulation.stop(); this.simulation = null; }
        this.activeContainerElement = null;
    };
    d3GraphManager.ticked = function() {
        if (!this.svg || !this.simulation) return;
        this.svg.selectAll("g.links line").attr("x1", d=>d.source.x).attr("y1", d=>d.source.y).attr("x2", d=>d.target.x).attr("y2", d=>d.target.y);
        this.svg.selectAll("g.notes rect").attr("x", d=>d.x-this.noteWidth/2).attr("y", d=>d.y-this.noteHeight/2);
        this.svg.selectAll("g.labels text").attr("x", d=>d.x).attr("y", d=>d.y);
    };
    // ensureInitialized full definition part for resize check and handler
    const originalEnsureInitialized = d3GraphManager.ensureInitialized;
    d3GraphManager.ensureInitialized = function(containerElement) {
        if (!containerElement) { console.error("D3: Provided container element is null or undefined."); return; }
        if (this.activeContainerElement === containerElement && this.svg) {
            const newWidth = containerElement.clientWidth; const newHeight = containerElement.clientHeight;
            if (newWidth > 0 && newHeight > 0) {
                const currentViewBox = this.svg.attr("viewBox")?.split(" ").map(Number);
                if (!currentViewBox || currentViewBox[2] !== newWidth || currentViewBox[3] !== newHeight) {
                    this.svg.attr("viewBox", `0 0 ${newWidth} ${newHeight}`);
                    if (this.simulation) { this.simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2)).alpha(0.3).restart(); }
                }
            }
            return; 
        }
        this.destroyVisualization(); 
        this.activeContainerElement = containerElement;
        const width = containerElement.clientWidth || 600; const height = containerElement.clientHeight || 350;
        this.svg = d3.select(containerElement).append("svg").attr("width", "100%").attr("height", "100%").attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet");
        this.simulation = d3.forceSimulation(this.graph.nodes).force("link", d3.forceLink(this.graph.links).id(d => d.id).distance(150)).force("charge", d3.forceManyBody().strength(-300)).force("center", d3.forceCenter(width / 2, height / 2)).on("tick", this.ticked.bind(this));
        this.svg.append("g").attr("class", "links"); this.svg.append("g").attr("class", "notes"); this.svg.append("g").attr("class", "labels");
        let resizeTimer;
        const handleResize = () => {
            if (!this.activeContainerElement || !this.svg) return;
            const newWidth = this.activeContainerElement.clientWidth; const newHeight = this.activeContainerElement.clientHeight;
            if (newWidth > 0 && newHeight > 0) {
                this.svg.attr("viewBox", `0 0 ${newWidth} ${newHeight}`);
                this.simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2)).alpha(0.3).restart();
            } else { this.svg.attr("viewBox", `0 0 600 350`); this.simulation.force("center", d3.forceCenter(300, 175)).alpha(0.3).restart(); }
        };
        const debouncedResize = () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(handleResize, 150); };
        this.resizeObserver = new ResizeObserver(debouncedResize); this.resizeObserver.observe(containerElement);
        if (width > 0 && height > 0) handleResize();
        this.update();
    };


    const MessageItem = { /* ... same as before (no changes needed here for localStorage) ... */
      props: ['message'], emits: ['edit', 'copy'],
      setup(props, { emit }) {
        const contentRef = ref(null), parsedContent = ref(''), isUser = props.message.role === 'user';
        const graphHostElement = ref(null), isDarkMode = ref(d3GraphManager.isDarkMode());
        let darkModeObserver = null;

        const updateContentAndRenderMath = (text) => {
          if (props.message.isGraphDisplaySlot) { parsedContent.value = ''; return; }
          if (props.message.isError) parsedContent.value = text;
          else if (props.message.role === 'model' || props.message.isSystemToolResponse) parsedContent.value = marked.parse(text || (props.message.isStreaming ? ' ' : ''));
          else parsedContent.value = marked.parse(text || '');
          nextTick(() => {
            if (contentRef.value && !props.message.isError && (props.message.role==='model' || (text&&text.includes('$')))) {
              try { if (typeof renderMathInElement === 'function') renderMathInElement(contentRef.value, {delimiters: [{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}], throwOnError: false}); } catch (e) { console.warn("KaTeX:", e); }
            }
          });
        };
        watch(() => props.message.parts[0].text, (nt) => { if (!props.message.isGraphDisplaySlot) updateContentAndRenderMath(nt); }, { immediate: true });
        watch(() => props.message.isStreaming, (is,was) => { if (was&&!is&&!props.message.isGraphDisplaySlot) updateContentAndRenderMath(props.message.parts[0].text); });
        const handleEdit = () => emit('edit', props.message), handleCopy = () => emit('copy', props.message);

        const setupGraphObserver = () => {
            const obs = new MutationObserver((ml) => {
                for (const m of ml) if (m.type === 'attributes' && m.attributeName === 'class') {
                    const newIsDark = d3GraphManager.isDarkMode();
                    if (isDarkMode.value !== newIsDark) { isDarkMode.value = newIsDark; if (d3GraphManager.svg) d3GraphManager.update(); }
                }
            });
            obs.observe(document.documentElement, { attributes: true });
            return obs;
        };
        onMounted(() => { if (props.message.isGraphDisplaySlot && graphHostElement.value) { d3GraphManager.ensureInitialized(graphHostElement.value); darkModeObserver = setupGraphObserver(); } });
        onUpdated(() => { if (props.message.isGraphDisplaySlot && graphHostElement.value) { d3GraphManager.ensureInitialized(graphHostElement.value); if(!darkModeObserver) darkModeObserver = setupGraphObserver(); } else if (!props.message.isGraphDisplaySlot && darkModeObserver) { darkModeObserver.disconnect(); darkModeObserver = null; } });
        onBeforeUnmount(() => {
            if (darkModeObserver) { darkModeObserver.disconnect(); darkModeObserver = null; }
            if (props.message.isGraphDisplaySlot && graphHostElement.value && d3GraphManager.activeContainerElement === graphHostElement.value) {
                d3GraphManager.destroyVisualization();
            }
        });
        return { isUser, handleEdit, handleCopy, contentRef, parsedContent, message: props.message, graphHostElement, isDarkMode };
      },
      template: `
        <div v-if="message.isGraphDisplaySlot" class="w-full my-3">
            <div ref="graphHostElement" class="graph-host-container" :class="isDarkMode ? 'bg-slate-800' : 'bg-slate-50'"></div>
        </div>
        <div v-else :class="['w-full flex group relative', isUser ? 'justify-end' : 'justify-start']" :data-message-id="message.id">
          <div :class="['max-w-[85%] sm:max-w-[80%]']">
              <div ref="contentRef" :class="['rendered-content prose prose-sm dark:prose-invert max-w-none', 'prose-p:my-0.5 prose-ul:my-1 prose-ol:my-1 prose-li:my-0 prose-headings:my-1 prose-pre:my-1.5', message.isSystemToolResponse ? 'p-2.5 text-xs italic bg-slate-200 dark:bg-slate-800 rounded-lg text-slate-500 dark:text-slate-400 border border-slate-300 dark:border-slate-700' : (message.isError ? 'p-2.5 border border-red-400/50 dark:border-red-600/50 rounded-lg bg-red-100/70 dark:bg-red-900/40 text-red-700 dark:text-red-300' : (isUser ? 'text-slate-700 dark:text-slate-200 text-right' : 'text-slate-800 dark:text-slate-100 text-left'))]" v-html="parsedContent"></div>
              <span v-if="message.isStreaming && !message.isError && !message.isSystemToolResponse" :class="['typing-cursor animate-blink mt-0.5', isUser ? 'float-right mr-1' : 'float-left ml-1']"></span>
          </div>
          <div v-if="!message.isError && !message.isSystemToolResponse && !message.isGraphDisplaySlot && (isUser || (!message.isStreaming && message.role === 'model'))" :class="['absolute top-1/2 -translate-y-1/2 flex items-center space-x-1.5 z-10 opacity-0 group-hover:opacity-100 transition-opacity duration-150', isUser ? 'left-0 -translate-x-full pr-2' : 'right-0 translate-x-full pl-2']">
              <button v-if="isUser" @click="handleEdit" title="Edit" class="p-1.5 rounded-full bg-slate-100/80 dark:bg-slate-700/80 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-500 dark:text-slate-300 shadow-md focus:outline-none focus:ring-1 focus:ring-sky-500"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3.5 h-3.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" /></svg></button>
              <button @click="handleCopy" title="Copy" class="copy-button p-1.5 rounded-full bg-slate-100/80 dark:bg-slate-700/80 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-500 dark:text-slate-300 shadow-md focus:outline-none focus:ring-1 focus:ring-sky-500"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3.5 h-3.5"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75" /></svg></button>
          </div>
        </div>
      `
    };


    createApp({
      components: { MessageItem },
      setup() {
        const messages = ref([]), newMessageText = ref(''), editingMessage = ref(null);
        const isLoading = ref(false), chatContainerRef = ref(null);
        const activeTempGraphSlotId = ref(null);
        const GRAPH_DISPLAY_DURATION = 7000;

        const geminiTools = [{ functionDeclarations: [ /* ... same tools ... */ ]}];
        // Minified geminiTools for brevity
        geminiTools[0].functionDeclarations = [
            {name:"create_note",description:"New note.",parameters:{type:"OBJECT",properties:{node_id:{type:"STRING",description:"Title."},node_body:{type:"STRING",description:"Body."}},required:["node_id"]}},
            {name:"connect_notes",description:"Connect notes.",parameters:{type:"OBJECT",properties:{source_id:{type:"STRING"},target_id:{type:"STRING"}},required:["source_id","target_id"]}},
            {name:"delete_note",description:"Delete note.",parameters:{type:"OBJECT",properties:{node_id:{type:"STRING"}},required:["node_id"]}},
            {name:"search_notes",description:"Highlight notes.",parameters:{type:"OBJECT",properties:{query:{type:"STRING"}},required:["query"]}},
            {name:"clear_graph",description:"Clear all.",parameters:{type:"OBJECT",properties:{}}},
            {name:"list_notes",description:"List all.",parameters:{type:"OBJECT",properties:{}}}
        ];


        const autoGrowTextarea=(ev)=>{ /* ... same ... */ };
        const scrollToBottom=(force=false)=>{ /* ... same ... */ };
        const addOrUpdateMessage=(role,text,id=null,stream=false,err=false,origMd=null,sysTool=false,graphSlot=false)=>{ /* ... same ... */ };
        const isGraphTool=(name)=>["create_note","connect_notes","delete_note","search_notes","clear_graph","list_notes"].includes(name);

        const handleGraphFunctionCall = (functionName, args) => {
            let result;
            switch (functionName) { /* ... same cases, d3GraphManager methods now handle saveToLocalStorage ... */
                case "create_note": result = d3GraphManager.addNode(args.node_id, args.node_body); break;
                case "connect_notes": result = d3GraphManager.addLink(args.source_id, args.target_id); break;
                case "delete_note": result = d3GraphManager.deleteNode(args.node_id); break;
                case "search_notes": result = d3GraphManager.highlightSearch(args.query); break;
                case "clear_graph": result = d3GraphManager.clearGraphData(); break;
                case "list_notes":
                    const notes = d3GraphManager.graph.nodes.map(n => ({ id: n.id, body: n.body }));
                    const summary = notes.length > 0 ? notes.map(n => `"${n.id}"${n.body?' (content)':' '}`).join(', ') : 'None.';
                    result = { success: true, message: `Notes: ${summary}. Details to AI.`, data: notes };
                    break; // list_notes doesn't modify data, so no save needed inside it.
                default: result = { success: false, message: `Unknown fn: ${functionName}` };
            }

            if (result.success && isGraphTool(functionName)) {
                if (activeTempGraphSlotId.value) {
                    const oldSlotIndex = messages.value.findIndex(m => m.id === activeTempGraphSlotId.value && m.isGraphDisplaySlot);
                    if (oldSlotIndex > -1) messages.value.splice(oldSlotIndex, 1);
                    activeTempGraphSlotId.value = null; 
                }
                const newTempGraphSlotId = 'graph-slot-' + Date.now();
                addOrUpdateMessage('system', '', newTempGraphSlotId, false, false, '', false, true);
                activeTempGraphSlotId.value = newTempGraphSlotId;
                setTimeout(() => {
                    if (activeTempGraphSlotId.value === newTempGraphSlotId) {
                        const index = messages.value.findIndex(m => m.id === newTempGraphSlotId && m.isGraphDisplaySlot);
                        if (index > -1) messages.value.splice(index, 1);
                        activeTempGraphSlotId.value = null;
                    }
                }, GRAPH_DISPLAY_DURATION);
            }
            return result;
        };

        const handleSendMessage=async()=>{ /* ... same ... */ };
        const fetchBotResponse=async(chatHist)=>{ /* ... same ... */ };
        const startEdit=(msg)=>{ /* ... same ... */ };
        const performCopy=(msg)=>{ /* ... same ... */ };
        const clearInput=()=>{ /* ... same ... */ };
        // Minified functions for brevity
        autoGrowTextarea=(ev)=>{const el=ev.target;el.style.height='auto';el.style.height=`${Math.min(el.scrollHeight,128)}px`;};
        scrollToBottom=(force=false)=>{nextTick(()=>{if(chatContainerRef.value){const{scrollTop,scrollHeight,clientHeight}=chatContainerRef.value;if(force||scrollHeight-scrollTop-clientHeight<150)chatContainerRef.value.scrollTop=scrollHeight;}});};
        addOrUpdateMessage=(role,text,id=null,stream=false,err=false,origMd=null,sysTool=false,graphSlot=false)=>{const exIdx=id?messages.value.findIndex(m=>m.id===id):-1;const msgData={id:id||Date.now().toString(36)+Math.random().toString(36).substring(2),role:role,parts:[{text:text}],originalMarkdown:origMd!==null?origMd:text,isStreaming:stream,isError:err,isSystemToolResponse:sysTool,isGraphDisplaySlot:graphSlot,timestamp:Date.now()};if(exIdx>-1)messages.value.splice(exIdx,1,msgData);else messages.value.push(msgData);scrollToBottom(role!=='model'||sysTool||graphSlot);return msgData.id;};
        handleSendMessage=async()=>{const txt=newMessageText.value.trim();if(!txt&&!editingMessage.value)return;isLoading.value=true;const ta=document.getElementById('message-input');if(editingMessage.value){const idx=messages.value.findIndex(m=>m.id===editingMessage.value.id);if(idx>-1){messages.value[idx].parts[0].text=txt;messages.value[idx].originalMarkdown=txt;}editingMessage.value=null;isLoading.value=false;}else{addOrUpdateMessage('user',txt,null,false,false,txt);const hist=messages.value.filter(m=>!m.isError&&!m.isSystemToolResponse&&!m.isGraphDisplaySlot).map(m=>({role:m.role,parts:m.role==='tool'?m.parts:[{text:m.originalMarkdown}]}));await fetchBotResponse(hist);}newMessageText.value='';if(ta)ta.style.height='auto';if(!editingMessage.value&&ta)ta.focus();};
        fetchBotResponse=async(chatHist)=>{const botMsgId=addOrUpdateMessage('model','',null,true);isLoading.value=true;const payload={contents:chatHist,tools:geminiTools,};try{const resp=await fetch(API_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});const msgIdx=messages.value.findIndex(m=>m.id===botMsgId);if(msgIdx===-1){isLoading.value=false;return;}if(!resp.ok){const errData=await resp.json().catch(()=>({error:{message:"API error"}}));const errMsg=errData.error?.message||`Err: ${resp.status}`;messages.value[msgIdx].parts[0].text=`<p>API Error:</p><p>${errMsg.replace(/\n/g,'<br>')}</p>`;messages.value[msgIdx].isError=true;messages.value[msgIdx].isStreaming=false;isLoading.value=false;return;}const data=await resp.json();if(!data.candidates||!data.candidates[0]||!data.candidates[0].content||!data.candidates[0].content.parts){messages.value[msgIdx].parts[0].text=`<p>Error:</p><p>Invalid AI response.</p>`;messages.value[msgIdx].isError=true;messages.value[msgIdx].isStreaming=false;isLoading.value=false;return;}const parts=data.candidates[0].content.parts;let textResp="",funcCall=null;for(const p of parts){if(p.text)textResp+=p.text;else if(p.functionCall){funcCall=p.functionCall;break;}}if(funcCall){messages.value[msgIdx].isStreaming=false;messages.value[msgIdx].parts[0].text=`<i>Tool: ${funcCall.name}...</i>`;messages.value[msgIdx].originalMarkdown=`[Tool: ${funcCall.name}]`;const funcRes=handleGraphFunctionCall(funcCall.name,funcCall.args);addOrUpdateMessage('system',`<b>Tool: ${funcCall.name}</b><br/>${funcRes.message.replace(/\n/g,'<br>')}`,null,false,!funcRes.success,`[Res: ${funcRes.message}]`,true);const newHist=[...chatHist,{role:'model',parts:[{functionCall:funcCall}]},{role:'tool',parts:[{functionResponse:{name:funcCall.name,response:{name:funcCall.name,content:funcRes}}}]}];await fetchBotResponse(newHist);}else if(textResp.trim()!==""){messages.value[msgIdx].originalMarkdown=textResp;let curTxt="",charIdx=0;const streamInt=setInterval(()=>{if(charIdx<textResp.length){curTxt+=textResp[charIdx++];messages.value[msgIdx].parts[0].text=curTxt;scrollToBottom();}else{clearInterval(streamInt);messages.value[msgIdx].parts[0].text=textResp;messages.value[msgIdx].isStreaming=false;scrollToBottom(true);isLoading.value=false;}},15);}else if(data.candidates[0].finishReason==="SAFETY"||data.promptFeedback?.blockReason){const reason=data.promptFeedback?.blockReason||"Safety";messages.value[msgIdx].parts[0].text=`<p>Blocked:</p><p>Reason: ${reason}.</p>`;messages.value[msgIdx].isError=true;messages.value[msgIdx].isStreaming=false;isLoading.value=false;}else{messages.value[msgIdx].parts[0].text=`<p>Info:</p><p>Empty AI response.</p>`;messages.value[msgIdx].isStreaming=false;isLoading.value=false;}}catch(err){console.error('Fetch Error:',err);const mIdx=messages.value.findIndex(m=>m.id===botMsgId);if(mIdx>-1){messages.value[mIdx].parts[0].text=`<p>Error:</p><p>${err.message}</p>`;messages.value[mIdx].isError=true;messages.value[mIdx].isStreaming=false;}isLoading.value=false;}finally{const fIdx=messages.value.findIndex(m=>m.id===botMsgId);if(fIdx>-1&&messages.value[fIdx].isStreaming){if(messages.value[fIdx].parts[0].text===''&&!messages.value[fIdx].isError)messages.value[fIdx].parts[0].text='<p>[Stream Error]</p>';messages.value[fIdx].isStreaming=false;}if(!messages.value.some(m=>m.isStreaming&&m.role==='model'))isLoading.value=false;scrollToBottom(true);}};
        startEdit=(msg)=>{editingMessage.value=msg;newMessageText.value=msg.originalMarkdown;const ta=document.getElementById('message-input');if(ta){ta.focus();nextTick(()=>autoGrowTextarea({target:ta}));}};
        performCopy=(msg)=>{const txt=msg.originalMarkdown||msg.parts[0].text;navigator.clipboard.writeText(txt.trim()).then(()=>{const el=document.querySelector(`[data-message-id="${msg.id}"]`);if(el){const btn=el.querySelector('.copy-button');if(btn){const origSVG=btn.innerHTML;btn.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-3.5 h-3.5 text-green-500"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>';setTimeout(()=>{btn.innerHTML=origSVG;},1500);}}}).catch(err=>console.error('Copy fail:',err));};
        clearInput=()=>{newMessageText.value='';editingMessage.value=null;const ta=document.getElementById('message-input');if(ta){ta.style.height='auto';ta.focus();}};


        onMounted(() => {
            d3GraphManager.init(); // This now loads from localStorage

            // Check if graph data was loaded and show it temporarily
            if (d3GraphManager.graph.nodes.length > 0 || d3GraphManager.graph.links.length > 0) {
                addOrUpdateMessage('system', "Loaded existing graph from previous session.", null, false, false, "[System: Graph Loaded from Storage]", true);

                const initialGraphSlotId = 'graph-slot-initial-load-' + Date.now();
                addOrUpdateMessage('system', '', initialGraphSlotId, false, false, '', false, true);
                activeTempGraphSlotId.value = initialGraphSlotId;

                // MessageItem for initialGraphSlotId will call ensureInitialized, which calls update()
                // using the loaded d3GraphManager.graph data.

                setTimeout(() => {
                    if (activeTempGraphSlotId.value === initialGraphSlotId) {
                        const index = messages.value.findIndex(m => m.id === initialGraphSlotId && m.isGraphDisplaySlot);
                        if (index > -1) messages.value.splice(index, 1);
                        activeTempGraphSlotId.value = null;
                    }
                }, GRAPH_DISPLAY_DURATION);
            }

            addOrUpdateMessage('model', "Hello! Your graph data is saved locally. Graph operations will show a temporary graph display. Try 'List notes' or 'Create a new note'.", null, false, false, "Hello! Your graph data is saved locally. Graph operations will show a temporary graph display. Try 'List notes' or 'Create a new note'.");
        });

        return { messages, newMessageText, isLoading, handleSendMessage, startEdit, performCopy, clearInput, chatContainerRef, editingMessage, autoGrowTextarea };
      }
    }).mount('#app');
  </script>
</body>
</html>
