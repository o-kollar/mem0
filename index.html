<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vue.js D3 Graph Chat UI - LLM Controlled</title>
  <script>
    // Force light mode by using class-based dark mode and not adding the 'dark' class
    tailwind.config = {
      darkMode: 'class',
    }
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css"
    crossorigin="anonymous"
  />
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"
    crossorigin="anonymous"
  ></script>
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"
    crossorigin="anonymous"
  ></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
    .animate-blink { animation: blink 1s step-end infinite; }
    .rendered-content { display: inline-block; width: 100%; }
    .typing-cursor { display: inline-block; width: 2px; height: 1.2em; background-color: currentcolor; vertical-align: text-bottom; margin-left: 1px; }
    .katex-display > .katex { text-align: initial; overflow-x: auto; overflow-y: hidden; max-width: 100%; }
    #chat-container::-webkit-scrollbar { width: 6px; }
    #chat-container::-webkit-scrollbar-track { background: transparent; }
    #chat-container::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.1); border-radius: 10px; }
    .dark #chat-container::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.1); }
    #chat-container::-webkit-scrollbar-thumb:hover { background-color: rgba(0,0,0,0.2); }
    .dark #chat-container::-webkit-scrollbar-thumb:hover { background-color: rgba(255,255,255,0.2); }
    .link { stroke: #9ca3af; stroke-width: 1.5px; }
    .dark .link { stroke: #6b7280; }
    .sticky-note { rx: 5; ry: 5; cursor: pointer; }
    .note-label { pointer-events: none; font-size: 12px; text-anchor: middle; dominant-baseline: central; fill: #1f2937; }
    .dark .note-label { fill: #f3f4f6; }
    .graph-host-container {
        position: relative; /* For positioning the details card */
        height: 350px;
        width: 100%;
        border-radius: 0.5rem;
        border: 1px solid #e2e8f0; /* slate-200 */
        margin-top: 1rem;
        margin-bottom: 1rem;
        transition: opacity 0.5s ease-in-out, max-height 0.5s ease-in-out;
        overflow: hidden;
    }
    .node-details-card {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 280px;
        max-height: calc(100% - 20px);
        background-color: #fff;
        border: 1px solid #e2e8f0; /* slate-200 */
        border-radius: 0.375rem; /* rounded-md */
        padding: 1rem; /* p-4 */
        z-index: 100;
        display: flex;
        flex-direction: column;
    }
    .dark .node-details-card {
        background-color: #334155; /* slate-700 */
        border-color: #475569; /* slate-600 */
        color: #f1f5f9; /* slate-100 */
    }
    .node-details-card h3 {
        margin-top: 0;
        margin-bottom: 0.75rem; /* mb-3 */
        font-size: 0.875rem; /* text-sm */
        font-weight: 600; /* font-semibold */
        border-bottom: 1px solid #e2e8f0; /* slate-200 */
        padding-bottom: 0.5rem; /* pb-2 */
        color: #1e293b; /* slate-800 */
    }
    .dark .node-details-card h3 {
        border-bottom-color: #475569; /* slate-600 */
        color: #f1f5f9; /* slate-100 */
    }
    .node-details-card-body {
        flex-grow: 1;
        overflow-y: auto;
        font-size: 0.875rem; /* text-sm */
        line-height: 1.4;
    }
     /* Custom scrollbar for card body */
    .node-details-card-body::-webkit-scrollbar { width: 5px; }
    .node-details-card-body::-webkit-scrollbar-track { background: transparent; }
    .node-details-card-body::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 10px; }
    .dark .node-details-card-body::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.2); }

    .node-details-card button.close-btn {
        position: absolute;
        top: 0.5rem; /* p-2 */
        right: 0.5rem; /* p-2 */
        background: transparent;
        border: none;
        font-size: 1.5rem; /* text-2xl-ish */
        line-height: 1;
        cursor: pointer;
        color: #64748b; /* slate-500 */
        padding: 0.25rem;
    }
    .dark .node-details-card button.close-btn {
        color: #94a3b8; /* slate-400 */
    }
    .node-details-card button.close-btn:hover {
        color: #1e293b; /* slate-800 */
    }
    .dark .node-details-card button.close-btn:hover {
        color: #f1f5f9; /* slate-100 */
    }
  </style>
</head>
<body class="bg-slate-100 text-slate-800 antialiased">

  <div id="app" class="flex flex-col h-screen w-full">
    <div id="chat-ui-area" class="flex-1 flex flex-col overflow-hidden bg-slate-100">
      <div ref="chatContainerRef" id="chat-container" class="flex-1 p-4 sm:p-6 overflow-y-auto flex flex-col space-y-5">
        <message-item
          v-for="msg in messages"
          :key="msg.id"
          :message="msg"
          @edit="startEdit"
          @copy="performCopy"
        ></message-item>
      </div>
      <form @submit.prevent="handleSendMessage" class="p-3 sm:p-4 bg-slate-200/50 backdrop-blur-xl border-t border-slate-300/50">
        <div class="relative flex items-end space-x-2">
          <div class="relative w-full min-w-[200px] flex-grow">
            <textarea
              id="message-input" rows="1" v-model="newMessageText"
              @keydown.enter.exact.prevent="handleSendMessage" @input="autoGrowTextarea"
              :disabled="isLoading"
              placeholder="Type your message or graph command..."
              class="peer w-full resize-none border-b-2 border-slate-300 bg-transparent pt-6 pb-2 font-sans text-sm font-normal text-slate-800 outline outline-0 transition-all placeholder:text-transparent focus:border-zinc-800 focus:outline-0 disabled:resize-none disabled:border-0 disabled:bg-slate-100 max-h-32"
              style="line-height: 1.5rem;"
            ></textarea>
            <label for="message-input"
              class="after:content[' '] pointer-events-none absolute left-0 -top-2.5 flex h-full w-full select-none !overflow-visible truncate text-[11px] font-normal leading-tight text-slate-500 transition-all after:absolute after:-bottom-0.5 after:block after:w-full after:scale-x-0 after:border-b-2 after:border-zinc-800 after:transition-transform after:duration-300 peer-placeholder-shown:text-sm peer-placeholder-shown:leading-[4.2] peer-placeholder-shown:text-slate-500 peer-focus:text-[11px] peer-focus:leading-tight peer-focus:text-zinc-800 peer-focus:after:scale-x-100 peer-focus:after:border-zinc-800 peer-disabled:text-transparent peer-disabled:peer-placeholder-shown:text-slate-500">
              Type your message or graph command...
            </label>
          </div>
          <button type="submit" :disabled="isLoading || !newMessageText.trim() && !editingMessage" class="flex-shrink-0 w-10 h-10 flex items-center justify-center text-white bg-zinc-800 rounded-full hover:bg-zinc-900 focus:ring-2 focus:outline-none focus:ring-zinc-500 disabled:bg-zinc-800/60 disabled:cursor-not-allowed transition-colors" title="Send message">
            <span v-if="isLoading"><svg aria-hidden="true" class="w-5 h-5 text-white animate-spin fill-zinc-400" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0492C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"/></svg></span>
            <span v-else><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" /></svg></span>
          </button>
        </div>
      </form>
    </div>
  </div>

  <script type="module">
    import { createApp, ref, nextTick, watch, onMounted, onUpdated, onBeforeUnmount, computed } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

    const API_KEY = "AIzaSyCvtMPDKK4oT_-1RB0MBOYoDwPjme6akoY"; // !!! REPLACE WITH YOUR ACTUAL GEMINI API KEY !!!
    const MODEL_NAME = "gemini-2.5-flash-lite-preview-06-1"; 
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${API_KEY}`;

    const d3GraphManager = {
        svg: null, simulation: null, graph: { nodes: [], links: [] },
        noteWidth: 120, noteHeight: 70, activeContainerElement: null, resizeObserver: null,
        localStorageKey: 'd3GraphChatUIData',
        isDarkMode: () => document.documentElement.classList.contains('dark'),
        selectedNodeId: null,
        selectionCallback: null,
        previousCenterTargetId: null, // Added to track the previously centered node


        loadFromLocalStorage() {
            try {
                const storedData = localStorage.getItem(this.localStorageKey);
                if (storedData) {
                    const parsedData = JSON.parse(storedData);
                    if (parsedData && Array.isArray(parsedData.nodes) && Array.isArray(parsedData.links)) {
                        this.graph = parsedData;
                        console.log("Graph data loaded from localStorage.");
                        return true;
                    } else {
                        console.warn("Invalid graph data structure in localStorage.");
                        this.graph = { nodes: [], links: [] };
                    }
                }
            } catch (error) {
                console.error("Error loading graph data from localStorage:", error);
                this.graph = { nodes: [], links: [] };
            }
            return false;
        },
        saveToLocalStorage() {
            try { localStorage.setItem(this.localStorageKey, JSON.stringify(this.graph)); }
            catch (error) { console.error("Error saving graph data to localStorage:", error); }
        },
        init() {
            this.loadFromLocalStorage();
            this.selectedNodeId = null; 
            this.previousCenterTargetId = null;
        },
        getCenterTargetNode() {
            if (this.selectedNodeId) {
                const selectedNode = this.graph.nodes.find(n => n.id === this.selectedNodeId);
                if (selectedNode) return selectedNode;
            }
            const highlightedNodes = this.graph.nodes.filter(n => n.isHighlighted);
            if (highlightedNodes.length === 1) {
                return highlightedNodes[0];
            }
            return null;
        },
        updateCenterForce() {
            if (!this.simulation || !this.activeContainerElement) return;

            const newTargetNode = this.getCenterTargetNode();
            const width = this.activeContainerElement.clientWidth || 600;
            const height = this.activeContainerElement.clientHeight || 350;

            // Unfix the previously centered node if it's no longer the target
            if (this.previousCenterTargetId) {
                const oldTarget = this.graph.nodes.find(n => n.id === this.previousCenterTargetId);
                if (oldTarget && (!newTargetNode || oldTarget.id !== newTargetNode.id)) {
                    oldTarget.fx = null;
                    oldTarget.fy = null;
                }
            }

            // Fix the new target node to the center
            if (newTargetNode) {
                newTargetNode.fx = width / 2;
                newTargetNode.fy = height / 2;
                this.previousCenterTargetId = newTargetNode.id;
            } else {
                // No specific target, ensure no node is fixed from previous centering
                 if (this.previousCenterTargetId) { // Check if there was a previous target that needs unpinning
                    const oldTarget = this.graph.nodes.find(n => n.id === this.previousCenterTargetId);
                    if (oldTarget) { // Ensure it exists before trying to unpin
                        oldTarget.fx = null;
                        oldTarget.fy = null;
                    }
                }
                this.previousCenterTargetId = null;
            }
            
            // The main simulation center force always targets the geometric center of the SVG.
            this.simulation.force("center", d3.forceCenter(width / 2, height / 2));
            
            // Restart simulation if changes might affect positions and it has cooled down
            if (this.simulation.alpha() < 0.1) {
                 this.simulation.alpha(0.3).restart();
            }
        },
        ensureInitialized(containerElement, selectionCallback) {
            if (!containerElement) { console.error("D3: Provided container element is null or undefined."); return; }
            this.selectionCallback = selectionCallback; 

            if (this.activeContainerElement === containerElement && this.svg) {
                const newWidth = containerElement.clientWidth; const newHeight = containerElement.clientHeight;
                if (newWidth > 0 && newHeight > 0) {
                    const currentViewBox = this.svg.attr("viewBox")?.split(" ").map(Number);
                     if (!currentViewBox || currentViewBox[2] !== newWidth || currentViewBox[3] !== newHeight) {
                        this.svg.attr("viewBox", `0 0 ${newWidth} ${newHeight}`);
                        this.updateCenterForce(); 
                        if (this.simulation) { this.simulation.alpha(0.3).restart(); }
                    }
                }
                return;
            }

            this.destroyVisualization(); 
            this.activeContainerElement = containerElement;
            this.selectionCallback = selectionCallback; 

            const width = containerElement.clientWidth || 600; const height = containerElement.clientHeight || 350;
            this.svg = d3.select(containerElement).append("svg").attr("width", "100%").attr("height", "100%").attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet")
                .on("click", (event) => { 
                    if (event.target === this.svg.node()) {
                        this.setSelectedNode(null);
                    }
                });

            this.simulation = d3.forceSimulation(this.graph.nodes)
                .force("link", d3.forceLink(this.graph.links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2)) 
                .on("tick", this.ticked.bind(this));

            this.svg.append("g").attr("class", "links"); this.svg.append("g").attr("class", "notes"); this.svg.append("g").attr("class", "labels");
            
            let resizeTimer;
            const handleResize = () => { 
                if (!this.activeContainerElement || !this.svg || !this.simulation) return;
                const newWidth = this.activeContainerElement.clientWidth; const newHeight = this.activeContainerElement.clientHeight;
                if (newWidth > 0 && newHeight > 0) {
                    this.svg.attr("viewBox", `0 0 ${newWidth} ${newHeight}`);
                    this.updateCenterForce(); 
                    this.simulation.alpha(0.3).restart();
                } else { 
                    this.svg.attr("viewBox", `0 0 600 350`); 
                    // No specific target node on invalid resize, default center force
                    this.simulation.force("center", d3.forceCenter(300, 175)).alpha(0.3).restart(); 
                }
            };
            const debouncedResize = () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(handleResize, 150); };
            this.resizeObserver = new ResizeObserver(debouncedResize); this.resizeObserver.observe(containerElement);
            if (width > 0 && height > 0) { 
                this.updateCenterForce(); 
                if (this.simulation) this.simulation.alpha(0.3).restart();
            }
            this.update();
        },
        destroyVisualization() {
            if (this.resizeObserver && this.activeContainerElement) { this.resizeObserver.unobserve(this.activeContainerElement); this.resizeObserver.disconnect(); this.resizeObserver = null; }
            if (this.svg) { this.svg.remove(); this.svg = null; }
            if (this.simulation) { this.simulation.stop(); this.simulation = null; }
            this.activeContainerElement = null;
            this.selectionCallback = null; 
            this.selectedNodeId = null;
            this.previousCenterTargetId = null;
        },
        ticked() {
            if (!this.svg || !this.simulation) return;
            this.svg.selectAll("g.links line").attr("x1", d=>d.source.x).attr("y1", d=>d.source.y).attr("x2", d=>d.target.x).attr("y2", d=>d.target.y);
            this.svg.selectAll("g.notes rect").attr("x", d=>d.x-this.noteWidth/2).attr("y", d=>d.y-this.noteHeight/2);
            this.svg.selectAll("g.labels text").attr("x", d=>d.x).attr("y", d=>d.y);
        },
        setSelectedNode(nodeId) {
            if (this.selectedNodeId === nodeId && nodeId !== null) { 
                this.selectedNodeId = null; 
            } else {
                this.selectedNodeId = nodeId;
            }

            if (this.selectionCallback) {
                const nodeData = this.selectedNodeId ? this.graph.nodes.find(n => n.id === this.selectedNodeId) : null;
                this.selectionCallback(nodeData);
            }
            this.update(); 
        },
        update() {
            if (!this.svg || !this.simulation || !this.activeContainerElement) return;
            this.simulation.nodes(this.graph.nodes); 
            this.simulation.force("link").links(this.graph.links); 
            
            const defaultFill = this.isDarkMode()?"#334155":"#fefce8"; 
            const defaultStroke = this.isDarkMode()?"#64748b":"#facc15"; 
            const highlightedFill = this.isDarkMode()?"#60a5fa":"#e4e4e7"; // zinc-200
            const highlightedStroke = this.isDarkMode()?"#93c5fd":"#a1a1aa"; // zinc-400
            const selectedStroke = this.isDarkMode()?"#a1a1aa":"#27272a"; // zinc-400 / zinc-800


            const link = this.svg.select("g.links").selectAll("line").data(this.graph.links, d=>`${d.source.id||d.source}-${d.target.id||d.target}`);
            link.exit().remove();
            link.enter().append("line").attr("class", "link").style("stroke", this.isDarkMode()?"#6b7280":"#9ca3af");

            const notes = this.svg.select("g.notes").selectAll("rect").data(this.graph.nodes, d=>d.id);
            notes.exit().remove();
            notes.enter().append("rect")
                .attr("class", "sticky-note")
                .attr("width", this.noteWidth)
                .attr("height", this.noteHeight)
                .on("click", (event, d) => {
                    event.stopPropagation(); 
                    this.setSelectedNode(d.id);
                })
                .call(d3.drag().on("start",this.dragStarted.bind(this)).on("drag",this.dragged.bind(this)).on("end",this.dragEnded.bind(this)))
                .merge(notes)
                .style("fill", d => d.isHighlighted ? highlightedFill : defaultFill)
                .style("stroke", d => {
                    if (d.id === this.selectedNodeId) return selectedStroke;
                    return d.isHighlighted ? highlightedStroke : defaultStroke;
                })
                .style("stroke-width", d => (d.id === this.selectedNodeId) ? 2.5 : 1.5);

            const labels = this.svg.select("g.labels").selectAll("text").data(this.graph.nodes, d=>d.id);
            labels.exit().remove();
            labels.enter().append("text").attr("class", "note-label").merge(labels)
                .text(d=>d.id.length>18?d.id.substring(0,15)+"...":d.id).style("fill", this.isDarkMode()?"#f3f4f6":"#1f2937");
            
            this.updateCenterForce(); 
            this.simulation.alpha(0.3).restart();
        },
        dragStarted(ev,d){if(!ev.active&&this.simulation)this.simulation.alphaTarget(0.3).restart();d.fx=d.x;d.fy=d.y;},
        dragged(ev,d){d.fx=ev.x;d.fy=ev.y;},
        dragEnded(ev,d){
            if(!ev.active && this.simulation) this.simulation.alphaTarget(0);

            const currentCenterTarget = this.getCenterTargetNode();
            const width = this.activeContainerElement ? (this.activeContainerElement.clientWidth || 600) : 600;
            const height = this.activeContainerElement ? (this.activeContainerElement.clientHeight || 350) : 350;

            if (d === currentCenterTarget) { // If the node just dragged *is* the one that should be centered
                d.fx = width / 2;   // Re-pin it to the center
                d.fy = height / 2;
            } else { // If the node just dragged is *not* the center target
                d.fx = null;        // Standard unpin after drag
                d.fy = null;
            }

            if (this.simulation) {
                // Re-heat simulation to reflect fx/fy changes and allow other nodes to resettle
                this.simulation.alpha(0.3).restart(); 
            }
        },
        addNode(id,body=""){if(!id||typeof id!=='string'||id.trim()==="")return{success:false,message:"ID empty."};id=id.trim();if(!this.graph.nodes.find(n=>n.id===id)){this.graph.nodes.push({id:id,body:body||"",isHighlighted:false});this.update();this.saveToLocalStorage();return{success:true,message:`Note "${id}" created.`};}return{success:false,message:`Note "${id}" exists.`};},
        addLink(srcId,tgtId){if(!srcId||!tgtId)return{success:false,message:"IDs required."};srcId=srcId.trim();tgtId=tgtId.trim();if(srcId===tgtId)return{success:false,message:"Self-link."};const sn=this.graph.nodes.find(n=>n.id===srcId),tn=this.graph.nodes.find(n=>n.id===tgtId);if(!sn)return{success:false,message:`Src "${srcId}" missing.`};if(!tn)return{success:false,message:`Tgt "${tgtId}" missing.`};const le=this.graph.links.find(l=>(l.source.id===srcId&&l.target.id===tgtId)||(l.source.id===tgtId&&l.target.id===srcId));if(!le){this.graph.links.push({source:srcId,target:tgtId});this.update();this.saveToLocalStorage();return{success:true,message:`Linked "${srcId}"-"${tgtId}".`};}return{success:false,message:`Link exists.`};},
        deleteNode(id){
            id=id.trim();
            const ne=this.graph.nodes.find(n=>n.id===id);
            if(!ne)return{success:false,message:`Note "${id}" missing.`};
            this.graph.nodes=this.graph.nodes.filter(n=>n.id!==id);
            this.graph.links=this.graph.links.filter(l=>(l.source.id||l.source)!==id&&(l.target.id||l.target)!==id);
            
            let triggerUpdate = true;
            if (this.selectedNodeId === id) {
                this.setSelectedNode(null); // This already calls update()
                triggerUpdate = false; 
            }
            if (this.previousCenterTargetId === id) { // If the deleted node was the one fixed to center
                this.previousCenterTargetId = null; // Clear it, updateCenterForce will handle general centering
            }

            if(triggerUpdate) this.update();

            this.saveToLocalStorage();
            return{success:true,message:`Note "${id}" deleted.`};
        },
        editNode(currentId, newIdParam, newBodyParam) {
            currentId = currentId ? currentId.trim() : null;
            const newId = newIdParam ? newIdParam.trim() : null;

            if (!currentId) {
                return { success: false, message: "Current node ID is required to edit." };
            }

            const nodeIndex = this.graph.nodes.findIndex(n => n.id === currentId);
            if (nodeIndex === -1) {
                return { success: false, message: `Node "${currentId}" not found.` };
            }
            const node = this.graph.nodes[nodeIndex]; 

            let idChanged = false;
            let bodyChanged = false;
            const originalId = node.id; 

            if (newId && newId !== originalId) {
                if (this.graph.nodes.some(n => n.id === newId)) {
                    return { success: false, message: `Cannot rename to "${newId}": ID already exists.` };
                }
                node.id = newId; 
                idChanged = true;

                this.graph.links.forEach(link => {
                    if (link.source === originalId) {
                        link.source = newId;
                    } else if (typeof link.source === 'object' && link.source.id === originalId) { 
                        link.source.id = newId;
                    }
                    if (link.target === originalId) {
                        link.target = newId;
                    } else if (typeof link.target === 'object' && link.target.id === originalId) { 
                        link.target.id = newId;
                    }
                });
                if (this.previousCenterTargetId === originalId) { // If renamed node was centered
                    this.previousCenterTargetId = newId;
                }
            }

            if (typeof newBodyParam === 'string') {
                if (node.body !== newBodyParam) {
                    node.body = newBodyParam;
                    bodyChanged = true;
                }
            }

            if (!idChanged && !bodyChanged) {
                return { success: true, message: `Node "${originalId}" was not changed (no new ID or body provided, or values were the same).` };
            }
            
            let selectionNeedsUpdate = false;
            if (this.selectedNodeId === originalId) {
                if (idChanged) {
                    this.selectedNodeId = newId; 
                }
                selectionNeedsUpdate = true;
            } else if (this.selectedNodeId === newId && idChanged) { 
                 selectionNeedsUpdate = true;
            }
            
            this.update(); // This will call updateCenterForce
            this.saveToLocalStorage();

            if (selectionNeedsUpdate && this.selectionCallback) {
                 const updatedNodeForCallback = this.graph.nodes.find(n => n.id === this.selectedNodeId);
                 this.selectionCallback(updatedNodeForCallback);
            }

            let message = `Node "${originalId}" updated.`;
            if (idChanged && newId) message += ` Renamed to "${newId}".`;
            if (bodyChanged) message += ` Body content ${newBodyParam === "" ? "cleared" : "updated"}.`;
            
            return { success: true, message: message.trim() };
        },
        highlightSearch(q){const nq=q?q.trim().toLowerCase():"";this.graph.nodes.forEach(n=>{n.isHighlighted=nq&&(n.id.toLowerCase().includes(nq)||(n.body&&n.body.toLowerCase().includes(nq)))});this.update();return{success:true,message:nq?`Highlight: "${q}".`:"Highlight cleared."};},
        clearGraphData(){
            this.graph.nodes=[];
            this.graph.links=[];
            this.previousCenterTargetId = null; // Clear fixed node tracker
            this.setSelectedNode(null); 
            // this.update(); // setSelectedNode(null) calls update()
            this.saveToLocalStorage();
            return{success:true,message:"Graph data cleared."};
        }
    };

    const MessageItem = {
      props: ['message'], emits: ['edit', 'copy'],
      setup(props, { emit }) {
        const contentRef = ref(null), parsedContent = ref(''), isUser = props.message.role === 'user';
        const graphHostElement = ref(null), isDarkMode = ref(d3GraphManager.isDarkMode());
        let darkModeObserver = null;

        const selectedRawNode = ref(null);

        const handleNodeSelectionChange = (nodeData) => {
            selectedRawNode.value = nodeData;
        };

        const displayedNodeDetails = computed(() => {
            if (selectedRawNode.value && selectedRawNode.value.body && selectedRawNode.value.body.trim() !== '') {
                return {
                    id: selectedRawNode.value.id,
                    parsedBody: marked.parse(selectedRawNode.value.body)
                };
            }
            return null;
        });

        const closeNodeCard = () => {
            if (props.message.isGraphDisplaySlot && d3GraphManager.activeContainerElement === graphHostElement.value) {
                d3GraphManager.setSelectedNode(null); 
            }
        };

        const updateContentAndRenderMath = (text) => {
          if (props.message.isGraphDisplaySlot) { parsedContent.value = ''; return; }
          if (props.message.isError) parsedContent.value = text;
          else if (props.message.role === 'model' || props.message.isSystemToolResponse) parsedContent.value = marked.parse(text || (props.message.isStreaming ? ' ' : ''));
          else parsedContent.value = marked.parse(text || '');
          nextTick(() => {
            if (contentRef.value && !props.message.isError && (props.message.role==='model' || (text&&text.includes('$')))) {
              try { if (typeof renderMathInElement === 'function') renderMathInElement(contentRef.value, {delimiters: [{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}], throwOnError: false}); } catch (e) { console.warn("KaTeX:", e); }
            }
            if (props.message.isGraphDisplaySlot && displayedNodeDetails.value && contentRef.value?.querySelector('.node-details-card-body')) {
                // KaTeX for card handled by watch(selectedRawNode)
            }
          });
        };
        watch(() => props.message.parts[0].text, (nt) => { if (!props.message.isGraphDisplaySlot) updateContentAndRenderMath(nt); }, { immediate: true });
        watch(() => props.message.isStreaming, (is,was) => { if (was&&!is&&!props.message.isGraphDisplaySlot) updateContentAndRenderMath(props.message.parts[0].text); });
        
        watch(selectedRawNode, (newNodeData) => {
            if (newNodeData && newNodeData.body && graphHostElement.value) {
                nextTick(() => {
                    const cardBody = graphHostElement.value.querySelector('.node-details-card-body');
                    if (cardBody && typeof renderMathInElement === 'function' && newNodeData.body.includes('$')) {
                         try { renderMathInElement(cardBody, {delimiters: [{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}], throwOnError: false}); } catch (e) { console.warn("KaTeX in card:", e); }
                    }
                });
            }
        }, { deep: true });


        const handleEdit = () => emit('edit', props.message), handleCopy = () => emit('copy', props.message);

        const setupGraphObserver = () => {
            const obs = new MutationObserver((ml) => {
                for (const m of ml) if (m.type === 'attributes' && m.attributeName === 'class') {
                    const newIsDark = d3GraphManager.isDarkMode();
                    if (isDarkMode.value !== newIsDark) {
                        isDarkMode.value = newIsDark;
                        if (props.message.isGraphDisplaySlot && d3GraphManager.activeContainerElement === graphHostElement.value && d3GraphManager.svg) {
                             d3GraphManager.update();
                        }
                    }
                }
            });
            obs.observe(document.documentElement, { attributes: true });
            return obs;
        };
        onMounted(() => {
            if (props.message.isGraphDisplaySlot && graphHostElement.value) {
                d3GraphManager.ensureInitialized(graphHostElement.value, handleNodeSelectionChange);
                darkModeObserver = setupGraphObserver();
            }
        });
        onUpdated(() => { 
            if (props.message.isGraphDisplaySlot && graphHostElement.value) {
                d3GraphManager.ensureInitialized(graphHostElement.value, handleNodeSelectionChange);
                if(!darkModeObserver) darkModeObserver = setupGraphObserver();
            } else if (!props.message.isGraphDisplaySlot && darkModeObserver) {
                darkModeObserver.disconnect(); darkModeObserver = null;
            }
        });
        onBeforeUnmount(() => {
            if (darkModeObserver) { darkModeObserver.disconnect(); darkModeObserver = null; }
            if (props.message.isGraphDisplaySlot && graphHostElement.value && d3GraphManager.activeContainerElement === graphHostElement.value) {
                d3GraphManager.destroyVisualization(); 
                 selectedRawNode.value = null; 
            }
        });
        return { isUser, handleEdit, handleCopy, contentRef, parsedContent, message: props.message, graphHostElement, isDarkMode, displayedNodeDetails, closeNodeCard };
      },
      template: `
        <div v-if="message.isGraphDisplaySlot" class="w-full my-3">
            <div ref="graphHostElement" class="graph-host-container" :class="isDarkMode ? 'bg-slate-800' : 'bg-slate-50'">
                <!-- Node Details Card -->
                <div v-if="displayedNodeDetails" class="node-details-card" :class="{ 'dark': isDarkMode }">
                    <h3>{{ displayedNodeDetails.id }}</h3>
                    <div class="node-details-card-body prose prose-sm dark:prose-invert max-w-none" v-html="displayedNodeDetails.parsedBody"></div>
                    <button @click="closeNodeCard" class="close-btn" title="Close note details">×</button>
                </div>
            </div>
        </div>
        <div v-else :class="['w-full flex group relative', isUser ? 'justify-end' : 'justify-start']" :data-message-id="message.id">
          <div :class="['max-w-[85%] sm:max-w-[80%]']">
              <div ref="contentRef" :class="['rendered-content prose prose-sm max-w-none', 'prose-p:my-0.5 prose-ul:my-1 prose-ol:my-1 prose-li:my-0 prose-headings:my-1 prose-pre:my-1.5', message.isSystemToolResponse ? 'p-2.5 text-xs italic bg-slate-200 rounded-lg text-slate-500 border border-slate-300' : (message.isError ? 'p-2.5 border border-red-400/50 rounded-lg bg-red-100/70 text-red-700' : (isUser ? 'text-slate-700 text-right' : 'text-slate-800 text-left'))]" v-html="parsedContent"></div>
              <span v-if="message.isStreaming && !message.isError && !message.isSystemToolResponse" :class="['typing-cursor animate-blink mt-0.5', isUser ? 'float-right mr-1' : 'float-left ml-1']"></span>
          </div>
          <div v-if="!message.isError && !message.isSystemToolResponse && !message.isGraphDisplaySlot && (isUser || (!message.isStreaming && message.role === 'model'))" :class="['absolute top-1/2 -translate-y-1/2 flex items-center space-x-1.5 z-10 opacity-0 group-hover:opacity-100 transition-opacity duration-150', isUser ? 'left-0 -translate-x-full pr-2' : 'right-0 translate-x-full pl-2']">
              <button v-if="isUser" @click="handleEdit" title="Edit" class="p-1.5 rounded-full bg-slate-100/80 hover:bg-slate-200 text-slate-500 border border-slate-300/70 focus:outline-none focus:ring-1 focus:ring-zinc-500"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3.5 h-3.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" /></svg></button>
              <button @click="handleCopy" title="Copy" class="copy-button p-1.5 rounded-full bg-slate-100/80 hover:bg-slate-200 text-slate-500 border border-slate-300/70 focus:outline-none focus:ring-1 focus:ring-zinc-500"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3.5 h-3.5"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75" /></svg></button>
          </div>
        </div>
      `
    };

    createApp({
      components: { MessageItem },
      setup() {
        const messages = ref([]), newMessageText = ref(''), editingMessage = ref(null);
        const isLoading = ref(false), chatContainerRef = ref(null);
        const activeTempGraphSlotId = ref(null);
        const GRAPH_DISPLAY_DURATION = 7000;

        const geminiTools = [{ functionDeclarations: []}];
        geminiTools[0].functionDeclarations = [
            {
                name:"create_note",
                description:"Creates a new note with a given ID (title) and an optional body. The body should be formatted as Markdown.",
                parameters:{
                    type:"OBJECT",
                    properties:{
                        node_id:{type:"STRING",description:"A unique identifier or title for the note."},
                        node_body:{type:"STRING",description:"The content/details for the note, formatted as Markdown. This field is optional. Provide an empty string to create a note with no body."}
                    },
                    required:["node_id"]
                }
            },
            {
                name:"edit_note",
                description:"Edits an existing note. Allows changing the note's ID (title) and/or its body content. If optional parameters (new_node_id, new_node_body) are not provided, the respective parts of the note remain unchanged. Providing an empty string for new_node_body will clear the note's body.",
                parameters: {
                    type: "OBJECT",
                    properties: {
                        node_id: {type: "STRING", description: "The current ID (title) of the note to be edited."},
                        new_node_id: {type: "STRING", description: "Optional. The new ID (title) for the note. If different from current, the note will be renamed."},
                        new_node_body: {type: "STRING", description: "Optional. The new Markdown content for the note's body. If provided, replaces the existing body. An empty string clears the body."}
                    },
                    required: ["node_id"]
                }
            },
            {name:"connect_notes",description:"Connect notes by their IDs.",parameters:{type:"OBJECT",properties:{source_id:{type:"STRING", description: "ID of the source note."},target_id:{type:"STRING", description: "ID of the target note."}},required:["source_id","target_id"]}},
            {name:"delete_note",description:"Delete a note by its ID.",parameters:{type:"OBJECT",properties:{node_id:{type:"STRING", description: "ID of the note to delete."}},required:["node_id"]}},
            {name:"search_notes",description:"Highlight notes based on a query string. The query will search note IDs and their Markdown content.",parameters:{type:"OBJECT",properties:{query:{type:"STRING", description: "The search term."}},required:["query"]}},
            {name:"clear_graph",description:"Clear all notes and links from the graph.",parameters:{type:"OBJECT",properties:{}}},
            {name:"list_notes",description:"List all notes currently in the graph, including their IDs and Markdown body content.",parameters:{type:"OBJECT",properties:{}}}
        ];

        const isGraphTool=(name)=>["create_note","edit_note","connect_notes","delete_note","search_notes","clear_graph","list_notes"].includes(name);

        const handleGraphFunctionCall = (functionName, args) => {
            let result;
            switch (functionName) {
                case "create_note": result = d3GraphManager.addNode(args.node_id, args.node_body); break;
                case "edit_note": result = d3GraphManager.editNode(args.node_id, args.new_node_id, args.new_node_body); break;
                case "connect_notes": result = d3GraphManager.addLink(args.source_id, args.target_id); break;
                case "delete_note": result = d3GraphManager.deleteNode(args.node_id); break;
                case "search_notes": result = d3GraphManager.highlightSearch(args.query); break;
                case "clear_graph": result = d3GraphManager.clearGraphData(); break;
                case "list_notes":
                    const notes = d3GraphManager.graph.nodes.map(n => ({ id: n.id, body: n.body }));
                    const summary = notes.length > 0 ? notes.map(n => `"${n.id}"${n.body && n.body.trim() !== ''?' (has content)':' (no content)'}`).join(', ') : 'No notes exist.';
                    result = { success: true, message: `Current notes: ${summary}. Full details (including Markdown body) provided to AI.`, data: notes };
                    break;
                default: result = { success: false, message: `Unknown fn: ${functionName}` };
            }

            if (result.success && isGraphTool(functionName)) {
                if (activeTempGraphSlotId.value) {
                    const oldSlotIndex = messages.value.findIndex(m => m.id === activeTempGraphSlotId.value && m.isGraphDisplaySlot);
                    if (oldSlotIndex > -1) messages.value.splice(oldSlotIndex, 1);
                    activeTempGraphSlotId.value = null;
                }
                const newTempGraphSlotId = 'graph-slot-' + Date.now();
                addOrUpdateMessage('system', '', newTempGraphSlotId, false, false, '', false, true);
                activeTempGraphSlotId.value = newTempGraphSlotId;
                setTimeout(() => {
                    if (activeTempGraphSlotId.value === newTempGraphSlotId) {
                        const index = messages.value.findIndex(m => m.id === newTempGraphSlotId && m.isGraphDisplaySlot);
                        if (index > -1) messages.value.splice(index, 1);
                        activeTempGraphSlotId.value = null;
                    }
                }, GRAPH_DISPLAY_DURATION);
            }
            return result;
        };

        const autoGrowTextarea=(ev)=>{const el=ev.target;el.style.height='auto';el.style.height=`${Math.min(el.scrollHeight,128)}px`;};
        const scrollToBottom=(force=false)=>{nextTick(()=>{if(chatContainerRef.value){const{scrollTop,scrollHeight,clientHeight}=chatContainerRef.value;if(force||scrollHeight-scrollTop-clientHeight<150)chatContainerRef.value.scrollTop=scrollHeight;}});};
        const addOrUpdateMessage=(role,text,id=null,stream=false,err=false,origMd=null,sysTool=false,graphSlot=false)=>{const exIdx=id?messages.value.findIndex(m=>m.id===id):-1;const msgData={id:id||Date.now().toString(36)+Math.random().toString(36).substring(2),role:role,parts:[{text:text}],originalMarkdown:origMd!==null?origMd:text,isStreaming:stream,isError:err,isSystemToolResponse:sysTool,isGraphDisplaySlot:graphSlot,timestamp:Date.now()};if(exIdx>-1)messages.value.splice(exIdx,1,msgData);else messages.value.push(msgData);scrollToBottom(role!=='model'||sysTool||graphSlot);return msgData.id;};
        const handleSendMessage=async()=>{const txt=newMessageText.value.trim();if(!txt&&!editingMessage.value)return;isLoading.value=true;const ta=document.getElementById('message-input');if(editingMessage.value){const idx=messages.value.findIndex(m=>m.id===editingMessage.value.id);if(idx>-1){messages.value[idx].parts[0].text=txt;messages.value[idx].originalMarkdown=txt;}editingMessage.value=null;isLoading.value=false;}else{addOrUpdateMessage('user',txt,null,false,false,txt);const hist=messages.value.filter(m=>!m.isError&&!m.isSystemToolResponse&&!m.isGraphDisplaySlot).map(m=>({role:m.role,parts:m.role==='tool'?m.parts:[{text:m.originalMarkdown}]}));await fetchBotResponse(hist);}newMessageText.value='';if(ta)ta.style.height='auto';if(!editingMessage.value&&ta)ta.focus();};
        const fetchBotResponse=async(chatHist)=>{const botMsgId=addOrUpdateMessage('model','',null,true);isLoading.value=true;const payload={contents:chatHist,tools:geminiTools,};try{const resp=await fetch(API_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});const msgIdx=messages.value.findIndex(m=>m.id===botMsgId);if(msgIdx===-1){isLoading.value=false;return;}if(!resp.ok){const errData=await resp.json().catch(()=>({error:{message:"API error"}}));const errMsg=errData.error?.message||`Err: ${resp.status}`;messages.value[msgIdx].parts[0].text=`<p>API Error:</p><p>${errMsg.replace(/\n/g,'<br>')}</p>`;messages.value[msgIdx].isError=true;messages.value[msgIdx].isStreaming=false;isLoading.value=false;return;}const data=await resp.json();if(!data.candidates||!data.candidates[0]||!data.candidates[0].content||!data.candidates[0].content.parts){messages.value[msgIdx].parts[0].text=`<p>Error:</p><p>Invalid AI response.</p>`;messages.value[msgIdx].isError=true;messages.value[msgIdx].isStreaming=false;isLoading.value=false;return;}const parts=data.candidates[0].content.parts;let textResp="",funcCall=null;for(const p of parts){if(p.text)textResp+=p.text;else if(p.functionCall){funcCall=p.functionCall;break;}}if(funcCall){messages.value[msgIdx].isStreaming=false;messages.value[msgIdx].parts[0].text=`<i>Tool: ${funcCall.name}...</i>`;messages.value[msgIdx].originalMarkdown=`[Tool: ${funcCall.name}]`;const funcRes=handleGraphFunctionCall(funcCall.name,funcCall.args);addOrUpdateMessage('system',`<b>Tool: ${funcCall.name}</b><br/>${funcRes.message.replace(/\n/g,'<br>')}`,null,false,!funcRes.success,`[Res: ${funcRes.message}]`,true);const newHist=[...chatHist,{role:'model',parts:[{functionCall:funcCall}]},{role:'tool',parts:[{functionResponse:{name:funcCall.name,response:{name:funcCall.name,content:funcRes}}}]}];await fetchBotResponse(newHist);}else if(textResp.trim()!==""){messages.value[msgIdx].originalMarkdown=textResp;let curTxt="",charIdx=0;const streamInt=setInterval(()=>{if(charIdx<textResp.length){curTxt+=textResp[charIdx++];messages.value[msgIdx].parts[0].text=curTxt;scrollToBottom();}else{clearInterval(streamInt);messages.value[msgIdx].parts[0].text=textResp;messages.value[msgIdx].isStreaming=false;scrollToBottom(true);isLoading.value=false;}},15);}else if(data.candidates[0].finishReason==="SAFETY"||data.promptFeedback?.blockReason){const reason=data.promptFeedback?.blockReason||"Safety";messages.value[msgIdx].parts[0].text=`<p>Blocked:</p><p>Reason: ${reason}.</p>`;messages.value[msgIdx].isError=true;messages.value[msgIdx].isStreaming=false;isLoading.value=false;}else{messages.value[msgIdx].parts[0].text=`<p>Info:</p><p>Empty AI response.</p>`;messages.value[msgIdx].isStreaming=false;isLoading.value=false;}}catch(err){console.error('Fetch Error:',err);const mIdx=messages.value.findIndex(m=>m.id===botMsgId);if(mIdx>-1){messages.value[mIdx].parts[0].text=`<p>Error:</p><p>${err.message}</p>`;messages.value[mIdx].isError=true;messages.value[mIdx].isStreaming=false;}isLoading.value=false;}finally{const fIdx=messages.value.findIndex(m=>m.id===botMsgId);if(fIdx>-1&&messages.value[fIdx].isStreaming){if(messages.value[fIdx].parts[0].text===''&&!messages.value[fIdx].isError)messages.value[fIdx].parts[0].text='<p>[Stream Error]</p>';messages.value[fIdx].isStreaming=false;}if(!messages.value.some(m=>m.isStreaming&&m.role==='model'))isLoading.value=false;scrollToBottom(true);}};
        const startEdit=(msg)=>{editingMessage.value=msg;newMessageText.value=msg.originalMarkdown;const ta=document.getElementById('message-input');if(ta){ta.focus();nextTick(()=>autoGrowTextarea({target:ta}));}};
        const performCopy=(msg)=>{const txt=msg.originalMarkdown||msg.parts[0].text;navigator.clipboard.writeText(txt.trim()).then(()=>{const el=document.querySelector(`[data-message-id="${msg.id}"]`);if(el){const btn=el.querySelector('.copy-button');if(btn){const origSVG=btn.innerHTML;btn.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-3.5 h-3.5 text-green-500"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>';setTimeout(()=>{btn.innerHTML=origSVG;},1500);}}}).catch(err=>console.error('Copy fail:',err));};
        
        onMounted(() => {
            d3GraphManager.init();
            if (d3GraphManager.graph.nodes.length > 0 || d3GraphManager.graph.links.length > 0) {
                addOrUpdateMessage('system', "Loaded existing graph from previous session.", null, false, false, "[System: Graph Loaded from Storage]", true);
                const initialGraphSlotId = 'graph-slot-initial-load-' + Date.now();
                addOrUpdateMessage('system', '', initialGraphSlotId, false, false, '', false, true);
                activeTempGraphSlotId.value = initialGraphSlotId;
                setTimeout(() => {
                    if (activeTempGraphSlotId.value === initialGraphSlotId) {
                        const index = messages.value.findIndex(m => m.id === initialGraphSlotId && m.isGraphDisplaySlot);
                        if (index > -1) messages.value.splice(index, 1);
                        activeTempGraphSlotId.value = null;
                    }
                }, GRAPH_DISPLAY_DURATION);
            }
            const welcomeMessage = "Hello! Click a note to see its details. You can create, edit, link, search, and delete notes. Try 'List notes', 'Create note \"My Idea\" with body \"- Point 1\\n- Point 2\"', or 'Edit note \"My Idea\" and change its body to \"Updated content.\"'."
            addOrUpdateMessage('model', welcomeMessage, null, false, false, welcomeMessage);
        });

        return { messages, newMessageText, isLoading, handleSendMessage, startEdit, performCopy, chatContainerRef, editingMessage, autoGrowTextarea };
      }
    }).mount('#app');
  </script>
</body>
</html>
