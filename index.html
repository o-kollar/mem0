<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mem0</title>
  <!-- Google Material Symbols -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <style>
    :root {
      --bg-color: #F8F9FA;
      --editor-bg: #FFFFFF;
      --text-color: #1c1c1c;
      --border-color: #EAE2D1;
      --primary-color: #4A90E2;
      --highlight-color: #FFECB3;
      --toolbar-bg: #262626;
      --toolbar-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
      --font-sans-serif: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --font-serif: "Georgia", "Times New Roman", serif;
    }
    body {
      font-family: var(--font-sans-serif);
      margin: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }
    #app-container { width: 100%; height: 100%; }
    #main-content {
      flex-grow: 1;
      padding: 40px;
      overflow-y: auto;
      display: flex;
      justify-content: center;
      position: relative;
    }
    .container { width: 100%; max-width: 720px; position: relative; }
    
    #top-network-container {
      position: relative;
      height: 250px;
      margin-bottom: 0;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background-color: #f5f5f5;
      box-sizing: border-box;
      padding: 0;
      overflow: hidden;
    }
    #main-network-graph {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #888;
    }
    #main-network-graph canvas { display: block; width: 100%; height: 100%; }
    
    #search-results-container {
        display: none;
        max-height: 150px;
        overflow-y: auto;
        background-color: #fff;
        border: 1px solid var(--border-color);
        border-top: none;
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        margin-bottom: 1em;
        box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
    }
    .search-result-item {
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .search-result-item:last-child { border-bottom: none; }
    .search-result-item:hover { background-color: #f7f7f7; }
    .search-result-item .title { font-weight: 500; }
    .search-result-item .score { font-size: 0.8em; color: #777; background-color: #eee; padding: 2px 6px; border-radius: 4px; }
    
    #search-container {
        position: absolute;
        top: 20px; left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        width: 80%; max-width: 450px;
        background-color: rgba(255, 255, 255, 0.65);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 25px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
    }
    #search-input {
        flex-grow: 1; width: 100%; padding: 10px 20px;
        border: none; background-color: transparent; font-size: 16px;
        outline: none; color: #333;
    }
    #search-input::placeholder { color: #666; }
    #clear-search-btn {
        background: none; border: none; cursor: pointer; display: none;
        padding: 8px; margin-right: 8px; color: #555;
        line-height: 0;
    }
    
    .material-symbols-outlined {
      font-size: 20px;
      vertical-align: middle;
      line-height: 1;
    }
    #clear-search-btn .material-symbols-outlined {
        font-size: 18px;
    }

    #main-actions {
      position: relative; /* For positioning the settings menu */
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
      margin-bottom: 20px;
    }
    #main-actions button {
      padding: 8px; border-radius: 6px; cursor: pointer;
      border: 1px solid #DADCE0; background-color: #FFF;
      font-weight: 500; font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0;
    }
    #main-actions button:hover { background-color: #F1F3F4; }
    #deleteNoteBtn { color: #D93025; }
    #deleteNoteBtn:hover { background-color: #FCE8E6 !important; }

    #settings-menu {
        position: absolute;
        top: calc(100% + 5px);
        right: 0;
        background-color: var(--editor-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        z-index: 200;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 200px;
    }
    #settings-menu.hidden {
        display: none;
    }
    #settings-menu button {
        border: none;
        background-color: transparent;
        text-align: left;
        padding: 8px 12px;
        width: 100%;
        display: flex;
        align-items: center;
        gap: 12px;
        font-weight: 500;
        font-size: 14px;
        cursor: pointer;
    }
     #settings-menu button:hover {
        background-color: #F1F3F4;
     }
    
    #note-title-editor {
        font-family: var(--font-serif); font-weight: 700; line-height: 1.3;
        font-size: 2.2em; margin-bottom: 1em; outline: none;
        padding: 0 48px; border: 1px solid transparent;
    }
    #note-content-editor {
      background-color: var(--editor-bg); padding: 32px 48px; min-height: 50vh; /* Increased min-height */
      font-size: 17px; line-height: 1.7; outline: none; border-radius: 8px;
      border: 1px solid var(--border-color); caret-color: var(--primary-color);
    }
    #note-content-editor:focus { border-color: var(--primary-color); }
    [data-placeholder]:empty:before { content: attr(data-placeholder); color: #aaa; pointer-events: none; display: block; }
    #note-content-editor h2, #note-content-editor h3 { font-family: var(--font-serif); font-weight: 700; line-height: 1.3; }
    #note-content-editor h2 { font-size: 1.6em; margin-bottom: 0.5em;}
    #note-content-editor h3 { font-size: 1.3em; margin-bottom: 0.5em;}
    
    #floating-toolbar { position: absolute; z-index: 100; display: none; padding: 5px; display: flex; gap: 4px; align-items: center; }
    .liquid-glass {
      position: relative; border-radius: 100vmax; isolation: isolate;
      background-color: rgba(255, 255, 255, 0.25);
      box-shadow: 0 6px 6px rgba(0, 0, 0, 0.2), 0 0 20px rgba(0, 0, 0, 0.1);
      text-align: center;
    }
    .liquid-glass::before, .liquid-glass::after { content: ""; position: absolute; inset: 0; border-radius: inherit; }
    .liquid-glass::before { backdrop-filter: blur(3px); filter: url(#glass-distortion); z-index: -1; }
    .liquid-glass::after { box-shadow: inset 2px 2px 1px 0 rgba(255, 255, 255, 0.5), inset -1px -1px 1px 1px rgba(255, 255, 255, 0.5); pointer-events: none; }
    #floating-toolbar button { background: none; border: none; color: var(--toolbar-bg); cursor: pointer; padding: 8px; border-radius: 50%; width: 38px; height: 38px; display: grid; place-items: center; position: relative; z-index: 1; }
    #floating-toolbar button:hover { background-color: rgba(0, 0, 0, 0.1); }
    .toolbar-separator { width: 1px; height: 20px; background-color: rgba(0, 0, 0, 0.2); margin: 0 4px; }
    
    @media (max-width: 768px) {
      #main-content { padding: 20px 15px; }
      #top-network-container { height: 220px; }
      #search-container { width: 95%; top: 15px; }
      #search-input { font-size: 14px; padding: 8px 15px; }
      #note-title-editor { padding: 0 10px; font-size: 1.8em; }
      #note-content-editor { padding: 16px; }
    }
  </style>
</head>
<body>

<svg style="display: none;"><filter id="glass-distortion"><feTurbulence type="fractalNoise" baseFrequency="0.05 0.05" numOctaves="3" result="noise" /><feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R" yChannelSelector="G" /></filter></svg>

<div id="app-container">
  <main id="main-content">
    <div class="container">
      <div id="top-network-container">
        <div id="search-container">
            <input type="search" id="search-input" placeholder="Search & filter notes..." disabled>
            <button id="clear-search-btn" title="Clear search">
                <span class="material-symbols-outlined">close</span>
            </button>
        </div>
        <div id="main-network-graph"></div>
      </div>
      
      <div id="search-results-container"></div>
      
      <div id="main-actions">
        <button id="newNoteBtn" title="New Note"><span class="material-symbols-outlined">add_circle</span></button>
        <button id="deleteNoteBtn" title="Delete Note"><span class="material-symbols-outlined">delete</span></button>
        <button id="settingsBtn" title="Settings">
            <span class="material-symbols-outlined">settings</span>
        </button>
        <div id="settings-menu" class="hidden">
            <button id="importDbBtn"><span class="material-symbols-outlined">upload_file</span>Import mem0</button>
            <button id="exportDbBtn"><span class="material-symbols-outlined">download_for_offline</span>Export mem0</button>
        </div>
      </div>

      <div id="floating-toolbar" class="liquid-glass">
        <button class="format-btn" data-command="bold" title="Bold"><span class="material-symbols-outlined">format_bold</span></button>
        <button class="format-btn" data-command="italic" title="Italic"><span class="material-symbols-outlined">format_italic</span></button>
        <button class="format-btn" id="createLinkBtn" title="Create Link"><span class="material-symbols-outlined">link</span></button>
        <div class="toolbar-separator"></div>
        <button class="format-btn" data-command="formatBlock" data-value="H2" title="Heading 2"><span class="material-symbols-outlined">title</span></button>
        <button class="format-btn" data-command="formatBlock" data-value="H3" title="Heading 3"><span class="material-symbols-outlined">format_size</span></button>
        <button class="format-btn" data-command="insertUnorderedList" title="Bulleted List"><span class="material-symbols-outlined">format_list_bulleted</span></button>
        <button class="format-btn" data-command="formatBlock" data-value="P" title="Paragraph"><span class="material-symbols-outlined">short_text</span></button>
      </div>
      
      <input type="file" id="db-file-input" accept=".sqlite,.db" style="display: none;">

      <div id="note-title-editor" contenteditable="true" data-placeholder="Your Title..."></div>
      <div id="note-content-editor" contenteditable="true" data-placeholder="Start writing here..."></div>

    </div>
  </main>
</div>

<!-- Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/gh/karpathy/tsnejs/tsne.js"></script>
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

<!-- App Logic -->
<script type="module">
    import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1';
    
    // --- DOM Elements ---
    const noteTitleEditor = document.getElementById('note-title-editor');
    const noteContentEditor = document.getElementById('note-content-editor');
    const newNoteBtn = document.getElementById('newNoteBtn');
    const deleteNoteBtn = document.getElementById('deleteNoteBtn');
    const floatingToolbar = document.getElementById('floating-toolbar');
    const tsneContainer = document.getElementById('top-network-container');
    const mainNetworkGraph = document.getElementById('main-network-graph');
    const searchInput = document.getElementById('search-input');
    const clearSearchBtn = document.getElementById('clear-search-btn');
    const searchResultsContainer = document.getElementById('search-results-container');
    const importDbBtn = document.getElementById('importDbBtn');
    const dbFileInput = document.getElementById('db-file-input');
    const exportDbBtn = document.getElementById('exportDbBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsMenu = document.getElementById('settings-menu');

    // --- State & DB Management ---
    let db;
    let SQL;
    let state = { currentNoteId: null, searchResults: new Map() };
    let debounceTimer, searchDebounceTimer;
    let embedder = null; 
    
    // --- T-SNE & 3D Visualization State ---
    let three, scene, camera, renderer, controls, pointCloud;
    let tsneInstance, tsneIteration = 0, isTsneRunning = false, noteIndexMap = [];
    const TSNE_MAX_ITERATIONS = 300;
    const TSNE_VIEW_SIZE = 100;
    const defaultColor = new THREE.Color('#000000');
    const selectedColor = new THREE.Color('#FFFF00');
    const searchMatchColor = new THREE.Color('#FF9800');
    const fadedColor = new THREE.Color('#222222');

    const DB_NAME = 'InspiredNotesDB';
    const DB_STORE_NAME = 'databaseFile';
    const DB_KEY = 'sqliteDb';
    const idb = {
        get: () => new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);
            request.onupgradeneeded = () => request.result.createObjectStore(DB_STORE_NAME);
            request.onsuccess = () => {
                const tx = request.result.transaction(DB_STORE_NAME, 'readonly');
                tx.objectStore(DB_STORE_NAME).get(DB_KEY).onsuccess = (e) => resolve(e.target.result);
                tx.oncomplete = () => request.result.close();
            };
            request.onerror = (e) => reject(e.target.error);
        }),
        set: (value) => new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);
            request.onupgradeneeded = () => request.result.createObjectStore(DB_STORE_NAME);
            request.onsuccess = () => {
                const tx = request.result.transaction(DB_STORE_NAME, 'readwrite');
                tx.objectStore(DB_STORE_NAME).put(value, DB_KEY);
                tx.oncomplete = () => { request.result.close(); resolve(); };
            };
            request.onerror = (e) => reject(e.target.error);
        }),
    };
    async function persistDb() {
        if (!db) return;
        const data = db.export();
        await idb.set(data);
    }
    const debouncedPersist = () => { clearTimeout(debounceTimer); debounceTimer = setTimeout(persistDb, 750); };

    // --- Semantic Search & Embedding ---
    async function generateEmbedding(text) {
        if (!embedder || !text) return null;
        try {
            const embedding = await embedder(text, { pooling: 'mean', normalize: true });
            return embedding.data;
        } catch (e) { console.error("Embedding generation failed:", e); return null; }
    }
    function cosineSimilarity(vecA, vecB) {
        let dotProduct = 0;
        for (let i = 0; i < vecA.length; i++) { dotProduct += vecA[i] * vecB[i]; }
        return dotProduct;
    }
    
    async function performSearch(query) {
        if (!query) {
            state.searchResults.clear();
            updatePointColors();
            renderSearchResultsList([]);
            return;
        }
        
        const queryEmbedding = await generateEmbedding(query);
        if (!queryEmbedding) return;

        const allNotesRes = db.exec("SELECT id, title, embedding FROM notes WHERE embedding IS NOT NULL");
        if (allNotesRes.length === 0) return;

        const notesWithScores = allNotesRes[0].values.map(row => {
            const [id, title, embeddingBlob] = row;
            const noteEmbedding = new Float32Array(embeddingBlob.buffer);
            const score = cosineSimilarity(queryEmbedding, noteEmbedding);
            return { id, title, score };
        })
        .filter(item => item.score > 0.45)
        .sort((a, b) => b.score - a.score);

        state.searchResults = new Map(notesWithScores.map(n => [n.id, n.score]));
        updatePointColors();
        renderSearchResultsList(notesWithScores);
    }
    
    function renderSearchResultsList(results) {
        if (results.length === 0) {
            searchResultsContainer.style.display = 'none';
            searchResultsContainer.innerHTML = '';
            return;
        }
        
        const html = results.map(note => `
            <div class="search-result-item" data-note-id="${note.id}">
                <span class="title">${note.title || 'Untitled Note'}</span>
                <span class="score">${note.score.toFixed(2)}</span>
            </div>
        `).join('');
        
        searchResultsContainer.innerHTML = html;
        searchResultsContainer.style.display = 'block';
    }

    // --- 3D Visualization Logic ---
    function initThreeJS() {
        three = {
            scene: new THREE.Scene(),
            camera: new THREE.PerspectiveCamera(75, tsneContainer.clientWidth / tsneContainer.clientHeight, 0.1, 1000),
            renderer: new THREE.WebGLRenderer({ antialias: true, alpha: true })
        };
        
        three.renderer.setSize(tsneContainer.clientWidth, tsneContainer.clientHeight);
        three.renderer.setPixelRatio(window.devicePixelRatio);
        mainNetworkGraph.innerHTML = '';
        mainNetworkGraph.appendChild(three.renderer.domElement);

        three.camera.position.z = 120;
        three.controls = new THREE.OrbitControls(three.camera, three.renderer.domElement);
        three.controls.enableDamping = true;
        three.controls.dampingFactor = 0.1;
        three.scene.add(new THREE.AmbientLight(0xffffff, 1.0));

        three.renderer.domElement.addEventListener('click', onCanvasClick);

        const resizeObserver = new ResizeObserver(entries => {
            const { width, height } = entries[0].contentRect;
            three.camera.aspect = width / height;
            three.camera.updateProjectionMatrix();
            three.renderer.setSize(width, height);
        });
        resizeObserver.observe(tsneContainer);
        animate3D();
    }
    
    function animate3D() {
        requestAnimationFrame(animate3D);
        three.controls.update();
        if (isTsneRunning && tsneIteration < TSNE_MAX_ITERATIONS) {
            tsneInstance.step();
            updatePointPositions();
            tsneIteration++;
        } else if (isTsneRunning) {
            isTsneRunning = false;
        }
        three.renderer.render(three.scene, three.camera);
    }

    async function renderTsne() {
        if (!three) initThreeJS();
        
        const notesWithEmbeddings = (await getAllNotes(false, true)).filter(n => n.embedding);
        if (notesWithEmbeddings.length < 2) {
            mainNetworkGraph.innerHTML = 'Need at least 2 notes with content to generate a map.';
            if (pointCloud) three.scene.remove(pointCloud);
            return;
        }

        noteIndexMap = notesWithEmbeddings.map(n => n.id);
        const embeddingVectors = notesWithEmbeddings.map(n => Array.from(new Float32Array(n.embedding.buffer)));

        tsneInstance = new tsnejs.tSNE({
            epsilon: 10,
            perplexity: Math.min(30, Math.floor((notesWithEmbeddings.length -1) / 3)),
            dim: 3
        });

        tsneInstance.initDataRaw(embeddingVectors);
        isTsneRunning = true;
        tsneIteration = 0;

        if (pointCloud) three.scene.remove(pointCloud);

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(noteIndexMap.length * 3), 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(noteIndexMap.length * 3), 3));
        
        const material = new THREE.PointsMaterial({ size: 4, vertexColors: true, sizeAttenuation: true });
        pointCloud = new THREE.Points(geometry, material);
        three.scene.add(pointCloud);
        
        updatePointColors();
    }
    
    function updatePointPositions() {
        if (!pointCloud || !tsneInstance) return;
        const solution = tsneInstance.getSolution();
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;
        for (let i = 0; i < solution.length; i++) {
            minX = Math.min(minX, solution[i][0]); maxX = Math.max(maxX, solution[i][0]);
            minY = Math.min(minY, solution[i][1]); maxY = Math.max(maxY, solution[i][1]);
            minZ = Math.min(minZ, solution[i][2]); maxZ = Math.max(maxZ, solution[i][2]);
        }
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const centerZ = (minZ + maxZ) / 2;
        const scale = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
        const positions = pointCloud.geometry.getAttribute('position');
        for (let i = 0; i < noteIndexMap.length; i++) {
            const x = scale > 0 ? ((solution[i][0] - centerX) / scale) * TSNE_VIEW_SIZE : 0;
            const y = scale > 0 ? ((solution[i][1] - centerY) / scale) * TSNE_VIEW_SIZE : 0;
            const z = scale > 0 ? ((solution[i][2] - centerZ) / scale) * TSNE_VIEW_SIZE : 0;
            positions.setXYZ(i, x, y, z);
        }
        positions.needsUpdate = true;
    }
    
    function updatePointColors() {
        if (!pointCloud) return;
        const colors = pointCloud.geometry.getAttribute('color');
        const color = new THREE.Color();
        const isSearchActive = state.searchResults.size > 0;
        
        for (let i = 0; i < noteIndexMap.length; i++) {
            const noteId = noteIndexMap[i];
            
            if (noteId === state.currentNoteId) {
                color.set(selectedColor);
            } else if (state.searchResults.has(noteId)) {
                color.set(searchMatchColor);
            } else if (isSearchActive) {
                color.set(fadedColor);
            } else {
                color.set(defaultColor);
            }
            colors.setXYZ(i, color.r, color.g, color.b);
        }
        colors.needsUpdate = true;
    }
    
    function onCanvasClick(event) {
        if (!pointCloud) return;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const rect = three.renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, three.camera);
        raycaster.params.Points.threshold = 3;
        const intersects = raycaster.intersectObject(pointCloud);
        if (intersects.length > 0) {
            const clickedNoteId = noteIndexMap[intersects[0].index];
            if (clickedNoteId) {
                selectNote(clickedNoteId);
            }
        }
    }
    
    // --- Note Management (SQL) ---
    async function getAllNotes(withContent = false, withEmbedding = false) {
        if (!db) return [];
        const query = `SELECT id, title${withContent ? ', content' : ''}${withEmbedding ? ', embedding' : ''} FROM notes ORDER BY id DESC`;
        const res = db.exec(query);
        if (res.length === 0) return [];
        const colNames = res[0].columns;
        return res[0].values.map(row => {
            const note = {};
            colNames.forEach((col, i) => note[col] = row[i]);
            return note;
        });
    }

    async function selectNote(id) {
        clearSearchBtn.click();
        state.currentNoteId = parseInt(id, 10);
        localStorage.setItem('inspired-notes-app-last-note', id);
        const stmt = db.prepare("SELECT title, content FROM notes WHERE id = :id");
        stmt.bind({ ':id': id });
        let note = null;
        if (stmt.step()) note = stmt.getAsObject();
        stmt.free();
        if (note) {
            noteTitleEditor.textContent = note.title;
            noteContentEditor.innerHTML = note.content;
        } else {
            const allNotes = await getAllNotes();
            if (allNotes.length > 0) await selectNote(allNotes[0].id);
            else { noteTitleEditor.innerHTML = ''; noteContentEditor.innerHTML = '<p><br></p>'; }
        }
        updatePointColors();
    }
    
    async function createNewNote() {
        const newId = new Date().getTime();
        const title = 'Untitled Note';
        const content = '<p><br></p>';
        const embeddingBlob = null;
        db.run("INSERT INTO notes (id, title, content, embedding) VALUES (?, ?, ?, ?)", [newId, title, content, embeddingBlob]);
        await persistDb();
        await renderTsne();
        await selectNote(newId);
        noteContentEditor.focus();
    }

    async function deleteCurrentNote() {
        if (!state.currentNoteId) return;
        if (confirm('Are you sure you want to delete this note?')) {
            db.run("DELETE FROM notes WHERE id = ?", [state.currentNoteId]);
            await persistDb();
            await renderTsne();
            const notes = await getAllNotes();
            const nextNoteId = notes.length > 0 ? notes[0].id : null;
            if (nextNoteId) await selectNote(nextNoteId);
            else await createNewNote();
        }
    }
    
    async function updateNoteContent() {
        if (!state.currentNoteId || !db) return;
        const title = noteTitleEditor.textContent.trim() || 'Untitled Note';
        const content = noteContentEditor.innerHTML;
        const textToEmbed = noteContentEditor.innerText;
        const embeddingData = await generateEmbedding(textToEmbed);
        const embeddingBlob = embeddingData ? new Uint8Array(embeddingData.buffer) : null;
        db.run("UPDATE notes SET title = ?, content = ?, embedding = ? WHERE id = ?", [title, content, embeddingBlob, state.currentNoteId]);
        await debouncedPersist();
        await renderTsne();
    }

    // --- Editor Logic ---
    function format(command, value = null) { document.execCommand(command, false, value); noteContentEditor.focus(); hideAllMenus(); }
    function hideAllMenus() { floatingToolbar.style.display = 'none'; }
    
    function handleSelectionChange() {
        const selection = window.getSelection();
        const mainContent = document.getElementById('main-content');
        if (!selection || selection.rangeCount === 0 || !noteContentEditor.contains(selection.anchorNode)) {
            hideAllMenus(); return;
        }
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        if ((rect.width === 0 && rect.height === 0) || (selection.isCollapsed && (range.startContainer.parentNode.tagName === 'P' && range.startContainer.parentNode.textContent.trim() === ''))) {
            hideAllMenus(); return;
        }
        floatingToolbar.style.display = 'flex';
        const toolbarHeight = floatingToolbar.offsetHeight, toolbarWidth = floatingToolbar.offsetWidth;
        const margin = 8;
        let topPosition = (rect.top > toolbarHeight + margin) ? rect.top + mainContent.scrollTop - toolbarHeight - margin : rect.bottom + mainContent.scrollTop + margin;
        const leftPosition = rect.left + (rect.width / 2) - (toolbarWidth / 2);
        floatingToolbar.style.top = `${topPosition}px`;
        floatingToolbar.style.left = `${leftPosition}px`;
    }

    // --- Utilities (Import/Export) ---
    async function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                db = new SQL.Database(new Uint8Array(e.target.result));
                await persistDb();
                alert('Database imported successfully! The application will now reload.');
                window.location.reload();
            } catch (err) {
                console.error("Error importing database:", err);
                alert("Failed to import database.");
            }
        };
        reader.readAsArrayBuffer(file);
        event.target.value = '';
    }

    async function exportDatabase() {
        if (!db) { alert("Database is not ready yet."); return; }
        if (state.currentNoteId) { await updateNoteContent(); await persistDb(); } 
        const blob = new Blob([db.export()], { type: "application/x-sqlite3" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `notes-backup-${new Date().toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-')}.sqlite`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // --- Event Listeners ---
    newNoteBtn.addEventListener('click', createNewNote);
    deleteNoteBtn.addEventListener('click', deleteCurrentNote);
    exportDbBtn.addEventListener('click', exportDatabase);
    importDbBtn.addEventListener('click', () => { if (confirm('Importing a database will overwrite all your current notes. Are you sure?')) { dbFileInput.click(); } });
    dbFileInput.addEventListener('change', handleFileImport);
    
    let debounceUpdateTimer;
    const debounceUpdate = () => { clearTimeout(debounceUpdateTimer); debounceUpdateTimer = setTimeout(updateNoteContent, 500); };
    
    noteContentEditor.addEventListener('input', debounceUpdate);
    noteTitleEditor.addEventListener('input', debounceUpdate);
    document.addEventListener('selectionchange', handleSelectionChange);
    
    floatingToolbar.addEventListener('mousedown', e => {
        e.preventDefault();
        const button = e.target.closest('button.format-btn');
        if (!button) return;
        if (button.id === 'createLinkBtn') {
            const url = prompt('Enter URL');
            if (url) format('createLink', url);
        } else {
            format(button.dataset.command, button.dataset.value);
        }
    });
    searchInput.addEventListener('input', (e) => {
        clearTimeout(searchDebounceTimer);
        const query = e.target.value.trim();
        clearSearchBtn.style.display = query ? 'block' : 'none';
        searchDebounceTimer = setTimeout(() => performSearch(query), 300);
    });
    clearSearchBtn.addEventListener('click', () => {
        searchInput.value = '';
        searchInput.dispatchEvent(new Event('input'));
    });
    searchResultsContainer.addEventListener('click', (e) => {
        const item = e.target.closest('.search-result-item');
        if (item && item.dataset.noteId) {
            selectNote(item.dataset.noteId);
        }
    });
    
    settingsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        settingsMenu.classList.toggle('hidden');
    });
    window.addEventListener('click', () => {
        settingsMenu.classList.add('hidden');
    });
    settingsMenu.addEventListener('click', e => e.stopPropagation());
    
    // --- App Initialization ---
    async function initialize() {
        mainNetworkGraph.textContent = 'Loading AI model...';
        const sqlJsReady = initSqlJs({ locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}` });
        
        try {
            embedder = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2', {
                quantized: true,
                progress_callback: data => { if (data.status === 'progress') mainNetworkGraph.textContent = `Loading model: ${(data.progress).toFixed(1)}%`; }
            });
            searchInput.disabled = false;
            
            SQL = await sqlJsReady;
            const dbFile = await idb.get();
            db = dbFile ? new SQL.Database(dbFile) : new SQL.Database();
            
            if (!dbFile) {
                db.run("CREATE TABLE notes (id INTEGER PRIMARY KEY, title TEXT, content TEXT, embedding BLOB);");
            } else {
                const hasEmbeddingCol = db.exec("PRAGMA table_info(notes);")[0].values.some(col => col[1] === 'embedding');
                if (!hasEmbeddingCol) { 
                    db.run("ALTER TABLE notes ADD COLUMN embedding BLOB;"); 
                }
            }
            
            mainNetworkGraph.textContent = 'Backfilling embeddings...';
            const notesToBackfill = db.exec("SELECT id, title, content FROM notes WHERE embedding IS NULL")[0];
            if (notesToBackfill && notesToBackfill.values.length > 0) {
                for (const row of notesToBackfill.values) {
                    const [id, title, content] = row;
                    const tempDiv = document.createElement('div'); tempDiv.innerHTML = content;
                    const embeddingData = await generateEmbedding(tempDiv.innerText);
                    const embeddingBlob = embeddingData ? new Uint8Array(embeddingData.buffer) : null;
                    db.run("UPDATE notes SET embedding = ? WHERE id = ?", [embeddingBlob, id]);
                }
                await persistDb();
            }
            
            mainNetworkGraph.textContent = 'Initializing visualization...';
            await renderTsne();
            
            const notes = await getAllNotes();
            if (notes.length === 0) { 
                await createNewNote(); 
            } else {
                const lastNoteId = localStorage.getItem('inspired-notes-app-last-note');
                const noteExists = lastNoteId && notes.some(n => n.id == lastNoteId);
                await selectNote(noteExists ? lastNoteId : notes[0].id);
            }
        } catch(err) {
            console.error("Failed to initialize:", err);
            mainNetworkGraph.textContent = 'Error during initialization.';
        }
    }
    
    initialize();
</script>
</body>
</html>
